{"version":3,"file":"static/js/705.8a245dc9.chunk.js","mappings":"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","sources":["components/Modal.tsx","hooks/modal.ts","store/episodes/actions.ts","store/episodes/selectors.ts","store/seasons/thunks.ts","store/shows/thunks.ts","store/episodes/thunks.ts","store/movies/actions.ts","store/movies/selectors.ts","store/seasons/actions.ts","store/seasons/selectors.ts","store/shows/actions.ts","store/shows/selectors.ts","services/http.ts","store/people/actions.ts","types/files/File.ts","services/databases/TMDb/api.ts","services/databases/TMDb/index.ts","services/drives/util.ts","services/drives/FTP/index.ts","services/drives/OneDrive/api.ts","services/drives/OneDrive/util.ts","types/files/Caption.ts","services/drives/OneDrive/index.ts","services/drives/index.tsx","services/indexing.ts","store/thunks.ts"],"sourcesContent":["import './Modal.scss'\nimport React, { FunctionComponent, useRef } from 'react'\nimport classNames from 'classnames'\nimport useOnClickOutside from 'use-onclickoutside'\n\ntype ModalProps = {\n  isActive: boolean\n  children?: React.ReactNode\n\n  onClose: () => void\n}\n\nexport const Modal: FunctionComponent<ModalProps> = ({\n  isActive,\n  onClose,\n  children,\n}) => {\n  const modalRef = useRef(null)\n  useOnClickOutside(modalRef, onClose)\n\n  return (\n    <div className={classNames('Modal', { active: isActive })}>\n      <div className=\"Modal__wrapper\" ref={modalRef}>\n        {children}\n      </div>\n    </div>\n  )\n}\n","import { useCallback, useState } from 'react'\n\nexport const useModal = (): [\n  show: boolean,\n  handleOpen: () => void,\n  handleClose: () => void,\n] => {\n  const [show, setShow] = useState(false)\n  const handleOpen = useCallback(() => setShow(true), [setShow])\n  const handleClose = useCallback(() => setShow(false), [setShow])\n\n  return [show, handleOpen, handleClose]\n}\n","import { EpisodesActionTypes, REMOVE_EPISODE, UPDATE_EPISODE } from './types'\nimport { Episode } from '../../types/items/Episode'\n\nexport const updateEpisode = (episode: Episode): EpisodesActionTypes => ({\n  type: UPDATE_EPISODE,\n  payload: { episode },\n})\n\nexport const removeEpisode = (id: string): EpisodesActionTypes => ({\n  type: REMOVE_EPISODE,\n  payload: { id },\n})\n","import { EpisodesState } from './types'\nimport { createSelector } from 'reselect'\n\nexport const episodeSelector = (id: string) => (state: EpisodesState) =>\n  state[id]\n\nexport const episodesSelector = (state: EpisodesState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const episodesBySeasonSelector = (seasonId: string) =>\n  createSelector(episodesSelector, (episodes) =>\n    episodes.filter((episode) => episode.seasonId === seasonId),\n  )\n","import { AppThunk } from '../index'\nimport { Season } from '../../types/items/Season'\nimport { Usage } from '../../types/items/Item'\nimport { showSelector } from '../shows/selectors'\nimport { updateSeason } from './actions'\nimport { updateShowProgress } from '../shows/thunks'\n\nexport const updateSeasonProgress =\n  (season: Season, progress: number): AppThunk<void> =>\n  (dispatch, getState) => {\n    const usage: Usage = {\n      lastWatched: new Date().toISOString(),\n      progress,\n    }\n    dispatch(updateSeason({ ...season, usage }))\n\n    const { shows } = getState()\n    const show = showSelector(season.showId)(shows)\n    if (show === undefined) throw new Error('parent show of season undefined')\n\n    dispatch(updateShowProgress(show, season.number))\n  }\n","import { AppThunk } from '../index'\nimport { Show } from '../../types/items/Show'\nimport { Usage } from '../../types/items/Item'\nimport { updateShow } from './actions'\n\nexport const updateShowProgress =\n  (show: Show, progress: number): AppThunk<void> =>\n  (dispatch) => {\n    const usage: Usage = {\n      lastWatched: new Date().toISOString(),\n      progress,\n    }\n    dispatch(updateShow({ ...show, usage }))\n  }\n","import { AppThunk } from '../index'\nimport { Episode } from '../../types/items/Episode'\nimport { Usage } from '../../types/items/Item'\nimport { seasonSelector } from '../seasons/selectors'\nimport { updateEpisode } from './actions'\nimport { updateSeasonProgress } from '../seasons/thunks'\n\nexport const updateEpisodeProgress =\n  (episode: Episode, progress: number): AppThunk<void> =>\n  (dispatch, getState) => {\n    const usage: Usage = {\n      lastWatched: new Date().toISOString(),\n      progress,\n    }\n    dispatch(updateEpisode({ ...episode, usage }))\n\n    const { seasons } = getState()\n    const season = seasonSelector(episode.seasonId)(seasons)\n    if (season === undefined)\n      throw new Error('parent season of episode undefined')\n\n    dispatch(updateSeasonProgress(season, episode.number))\n  }\n\nexport const removeFilesByProvider =\n  (episode: Episode, providerId: string): AppThunk<void> =>\n  (dispatch) => {\n    dispatch(\n      updateEpisode({\n        ...episode,\n        sources: episode.sources.filter(\n          (source) => source.provider.providerId !== providerId,\n        ),\n        captions: episode.captions.filter(\n          (caption) => caption.provider.providerId !== providerId,\n        ),\n      }),\n    )\n  }\n","import { MoviesActionTypes, REMOVE_MOVIE, UPDATE_MOVIE } from './types'\nimport { Movie } from '../../types/items/Movie'\n\nexport const updateMovie = (movie: Movie): MoviesActionTypes => ({\n  type: UPDATE_MOVIE,\n  payload: { movie },\n})\n\nexport const removeMovie = (id: string): MoviesActionTypes => ({\n  type: REMOVE_MOVIE,\n  payload: { id },\n})\n","import { isInProgress, wasRecentlyWatched } from '../../util'\nimport { Movie } from '../../types/items/Movie'\nimport { MoviesState } from './types'\nimport { Person } from '../../types/items/Person'\nimport { RECENTLY_WATCHED_THRESHOLD } from '../../constants'\nimport { createSelector } from 'reselect'\n\nexport const movieSelector = (id: string) => (state: MoviesState) => state[id]\n\nexport const moviesSelector = (state: MoviesState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const inProgressSelector = (state: MoviesState) =>\n  moviesSelector(state).filter(isInProgress)\n\nexport const recentlyWatchedSelector = (state: MoviesState) =>\n  moviesSelector(state).filter((movie) =>\n    wasRecentlyWatched(movie, RECENTLY_WATCHED_THRESHOLD),\n  )\n\nexport const moviesByPersonSelector = (id: string) =>\n  createSelector(moviesSelector, (movies) =>\n    movies.filter(\n      (movie) =>\n        movie.cast.find((person) => person.id === id) ||\n        movie.crew.find((person) => person.id === id),\n    ),\n  )\n\nexport const moviesPersonSelector = <T extends Person>(\n  id: string,\n  fn: (movie: Movie) => T[],\n) =>\n  createSelector(moviesSelector, (movies) =>\n    movies\n      .map(fn)\n      .reduce((acc, people) => acc.concat(people), [])\n      .filter((person) => person.id === id),\n  )\n","import { REMOVE_SEASON, SeasonsActionTypes, UPDATE_SEASON } from './types'\nimport { Season } from '../../types/items/Season'\n\nexport const updateSeason = (season: Season): SeasonsActionTypes => ({\n  type: UPDATE_SEASON,\n  payload: { season },\n})\n\nexport const removeSeason = (id: string): SeasonsActionTypes => ({\n  type: REMOVE_SEASON,\n  payload: { id },\n})\n","import { isInProgress, wasRecentlyWatched } from '../../util'\nimport { Person } from '../../types/items/Person'\nimport { RECENTLY_WATCHED_THRESHOLD } from '../../constants'\nimport { Season } from '../../types/items/Season'\nimport { SeasonsState } from './types'\nimport { createSelector } from 'reselect'\n\nexport const seasonSelector = (id: string) => (state: SeasonsState) => state[id]\n\nexport const seasonsSelector = (state: SeasonsState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const inProgressSelector = (state: SeasonsState) =>\n  seasonsSelector(state).filter(isInProgress)\n\nexport const recentlyWatchedSelector = (state: SeasonsState) =>\n  seasonsSelector(state).filter((season) =>\n    wasRecentlyWatched(season, RECENTLY_WATCHED_THRESHOLD),\n  )\n\nexport const seasonsByShowSelector = (showId: string) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons.filter((season) => season.showId === showId),\n  )\n\nexport const seasonsByPersonSelector = (id: string) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons.filter(\n      (season) =>\n        season.cast.find((person) => person.id === id) ||\n        season.crew.find((person) => person.id === id),\n    ),\n  )\n\nexport const seasonsPersonSelector = <T extends Person>(\n  id: string,\n  fn: (season: Season) => T[],\n) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons\n      .map(fn)\n      .reduce((acc, people) => acc.concat(people), [])\n      .filter((person) => person.id === id),\n  )\n","import { REMOVE_SHOW, ShowsActionTypes, UPDATE_SHOW } from './types'\nimport { Show } from '../../types/items/Show'\n\nexport const updateShow = (show: Show): ShowsActionTypes => ({\n  type: UPDATE_SHOW,\n  payload: { show },\n})\n\nexport const removeShow = (id: string): ShowsActionTypes => ({\n  type: REMOVE_SHOW,\n  payload: { id },\n})\n","import { ShowsState } from './types'\n\nexport const showSelector = (id: string) => (state: ShowsState) => state[id]\n\nexport const showsSelector = (state: ShowsState) =>\n  Object.keys(state).map((id) => state[id]!)\n","import { APIError } from '../errors/APIError'\n\nenum HttpMethod {\n  GET = 'GET',\n}\n\ntype Params = Record<string, string>\n\nconst buildUrl = (baseUrl: string, path: string, params?: Params) => {\n  const url = new URL(`${baseUrl}/${path}`)\n\n  if (params !== undefined)\n    for (const [key, value] of Object.entries(params))\n      url.searchParams.append(key, value)\n\n  return url\n}\n\nconst http = async <T>(\n  baseUrl: string,\n  path: string,\n  method: HttpMethod,\n  accessToken: string,\n  params?: Params,\n): Promise<T> => {\n  const response = await fetch(buildUrl(baseUrl, path, params).href, {\n    method,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n  })\n\n  // check if response is empty\n  // if empty just return an empty object\n  const text = await response.text()\n  const body = text ? JSON.parse(text) : {}\n\n  if (response.ok) return body\n  else throw new APIError(response.status, response.statusText)\n}\n\nexport const get = <T>(\n  baseUrl: string,\n  path: string,\n  accessToken: string,\n  params: Params,\n) => http<T>(baseUrl, path, HttpMethod.GET, accessToken, params)\n","import { ADD_PERSON, PeopleActionTypes, RESET_PEOPLE } from './types'\n\nexport const addPerson = (id: string): PeopleActionTypes => ({\n  type: ADD_PERSON,\n  payload: { id },\n})\n\nexport const resetPeople = (): PeopleActionTypes => ({\n  type: RESET_PEOPLE,\n})\n","import { Caption } from './Caption'\nimport { FileProvider } from './FileProvider'\nimport { Video } from './Video'\n\nexport enum FileKind {\n  Video,\n  Caption,\n}\n\nexport interface IFile<T extends FileProvider> {\n  kind: FileKind\n  id: string\n  name: string\n  provider: T\n}\n\nexport type File = Caption | Video\n","import {\n  MovieCreditsResponse,\n  MovieDetailsResponse,\n  SearchMoviesResponse,\n  SearchTVShowsResponse,\n  TVEpisodeResponse,\n  TVSeasonCreditsResponse,\n  TVSeasonDetailsResponse,\n  TVShowDetailsResponse,\n} from './types'\nimport { get } from '../../http'\nimport i18next from 'i18next'\n\nconst BASE_URL = 'https://api.themoviedb.org/3'\nconst ACCESS_TOKEN = process.env.REACT_APP_TMDB_API_READ_ACCESS_TOKEN!\n\nexport const findMovie = async (query: string) => {\n  const { results } = await get<SearchMoviesResponse>(\n    BASE_URL,\n    'search/movie',\n    ACCESS_TOKEN,\n    { language: i18next.language, query },\n  )\n\n  if (results.length === 0) return undefined\n  else return results[0].id\n}\n\nexport const findShow = async (query: string) => {\n  const { results } = await get<SearchTVShowsResponse>(\n    BASE_URL,\n    'search/tv',\n    ACCESS_TOKEN,\n    { language: i18next.language, query },\n  )\n\n  if (results.length === 0) return undefined\n  else return results[0].id\n}\n\nexport const fetchMovie = (id: number) =>\n  get<MovieDetailsResponse>(BASE_URL, `movie/${id}`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchMovieCredits = (id: number) =>\n  get<MovieCreditsResponse>(BASE_URL, `movie/${id}/credits`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchShow = (id: number) =>\n  get<TVShowDetailsResponse>(BASE_URL, `tv/${id}`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchSeason = (showId: number, seasonNumber: number) =>\n  get<TVSeasonDetailsResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n\nexport const fetchSeasonCredits = (showId: number, seasonNumber: number) =>\n  get<TVSeasonCreditsResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}/credits`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n\nexport const fetchEpisode = (\n  showId: number,\n  seasonNumber: number,\n  episodeNumber: number,\n) =>\n  get<TVEpisodeResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}/episode/${episodeNumber}`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n","import { Episode, EpisodeLike } from '../../../types/items/Episode'\nimport { Movie, MovieLike } from '../../../types/items/Movie'\nimport { Season, SeasonLike } from '../../../types/items/Season'\nimport { Show, ShowLike } from '../../../types/items/Show'\nimport { buildEpisode, buildMovie, buildSeason, buildShow } from './util'\nimport {\n  fetchEpisode,\n  fetchMovie,\n  fetchMovieCredits,\n  fetchSeason,\n  fetchSeasonCredits,\n  fetchShow,\n} from './api'\n\nexport const fetchEpisodeMetadata = async (\n  showId: string,\n  seasonId: string,\n  episode: EpisodeLike,\n): Promise<Episode> => {\n  const response = await fetchEpisode(\n    episode.showTmdbId,\n    episode.seasonNumber,\n    episode.number,\n  )\n\n  return buildEpisode(showId, seasonId, episode, response)\n}\n\nexport const fetchMovieMetadata = async (movie: MovieLike): Promise<Movie> => {\n  const response = await fetchMovie(movie.tmdbId)\n  const creditsResponse = await fetchMovieCredits(movie.tmdbId)\n\n  return buildMovie(movie, response, creditsResponse)\n}\n\nexport const fetchSeasonMetadata = async (\n  show: Show,\n  season: SeasonLike,\n): Promise<Season> => {\n  const response = await fetchSeason(season.showTmdbId, season.number)\n  const creditsResponse = await fetchSeasonCredits(\n    season.showTmdbId,\n    season.number,\n  )\n\n  return buildSeason(show, season, response, creditsResponse)\n}\n\nexport const fetchShowMetadata = async (show: ShowLike): Promise<Show> => {\n  const response = await fetchShow(show.tmdbId)\n\n  return buildShow(show, response)\n}\n","import { CaptionType, VTT_EXTENSION } from '../../types/files/Caption'\nimport { EpisodeIndexResponse, SeasonIndexResponse } from './types'\nimport {\n  M4V_EXTENSION,\n  MKV_EXTENSION,\n  MP4_EXTENSION,\n  VideoType,\n  WEBM_EXTENSION,\n} from '../../types/files/Video'\nimport { File } from '../../types/files/File'\nimport { ProviderKind } from '../../types/providers/Provider'\n\nexport const parseFileName = (fileName: string) => ({\n  name: fileName.split('.').shift()!,\n  extension: fileName.split('.').pop(),\n})\n\nexport const parseCaptionType = (\n  extension: string,\n): CaptionType | undefined => {\n  switch (extension) {\n    case VTT_EXTENSION:\n      return VTT_EXTENSION\n  }\n}\n\nexport const parseVideoType = (extension: string): VideoType | undefined => {\n  switch (extension) {\n    case MP4_EXTENSION:\n      return MP4_EXTENSION\n    case M4V_EXTENSION:\n      return M4V_EXTENSION\n    case MKV_EXTENSION:\n      return MKV_EXTENSION\n    case WEBM_EXTENSION:\n      return WEBM_EXTENSION\n  }\n}\n\nexport const buildFileId = (kind: ProviderKind, id: string) => `${kind}@${id}`\n\nexport const buildEpisodeIndexResponse = (\n  number: number,\n  files: File[] = [],\n): EpisodeIndexResponse => ({ number, files })\n\nexport const buildSeasonIndexResponse = (\n  number: number,\n  episodes: EpisodeIndexResponse[] = [],\n): SeasonIndexResponse => ({ number, episodes })\n","// import { fetchItem, fetchItems, getClient } from './api'\nimport { CannotFindFileError } from '../../../errors/CannotFindFileError'\nimport { FTP } from '../../../types/providers/FTP'\nimport { File } from '../../../types/files/File'\nimport {\n  // EpisodeIndexResponse,\n  IndexResponse,\n  // MovieIndexResponse,\n  // SeasonIndexResponse,\n  // ShowIndexResponse,\n} from '../types'\n// import { ProviderKind } from '../../../types/providers/Provider'\n// import { buildFile } from './util'\n// import { notUndefined } from '../../../util'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const updateFile = async (provider: FTP, file: File): Promise<File> => {\n  throw new CannotFindFileError(file)\n\n  // const client = await getClient(\n  //   provider.host,\n  //   provider.port,\n  //   provider.username,\n  //   provider.password,\n  //   provider.secure,\n  // )\n  // const response = await fetchItem(client, file.provider.fileName)\n  // if (response === undefined) throw new CannotFindFileError(file)\n  // if (file.provider.kind !== ProviderKind.FTP)\n  //   throw new Error(\n  //     'Internal error: attempted to update file with the wrong provider.',\n  //   )\n  // const newFile = buildFile(provider.id, file.provider.path)(response)\n\n  // if (newFile !== undefined) return newFile\n  // else throw new CannotFindFileError(file)\n}\n\n// const indexFiles = async (\n//   providerId: string,\n//   client: Client,\n//   path: string,\n// ): Promise<File[]> => {\n//   const filesResponse = await fetchItems(client, path)\n//   return filesResponse.map(buildFile(providerId, path)).filter(notUndefined)\n// }\n\n// const indexMovies = async (\n//   providerId: string,\n//   client: Client,\n//   path: string | undefined,\n// ): Promise<MovieIndexResponse[]> => {\n//   if (path === undefined) return []\n\n//   const moviesResponse = await fetchItems(client, path)\n\n//   return Promise.all(\n//     moviesResponse.map(async (movieResponse) => ({\n//       name: movieResponse.name,\n//       files: await indexFiles(\n//         providerId,\n//         client,\n//         `${path}/${movieResponse.name}`,\n//       ),\n//     })),\n//   )\n// }\n\n// const indexEpisodes = async (\n//   providerId: string,\n//   client: Client,\n//   seasonFolderPath: string,\n// ): Promise<EpisodeIndexResponse[]> => {\n//   const episodesResponse = await fetchItems(client, seasonFolderPath)\n\n//   const episodes = await Promise.all(\n//     episodesResponse.map(async (episodeResponse) => {\n//       const number = Number.parseInt(episodeResponse.name)\n//       if (isNaN(number)) return\n\n//       return {\n//         number,\n//         files: await indexFiles(\n//           providerId,\n//           client,\n//           `${seasonFolderPath}/${episodeResponse.name}`,\n//         ),\n//       }\n//     }),\n//   )\n\n//   return episodes.filter(notUndefined)\n// }\n\n// const indexSeasons = async (\n//   providerId: string,\n//   client: Client,\n//   showFolderPath: string,\n// ): Promise<SeasonIndexResponse[]> => {\n//   const seasonsResponse = await fetchItems(client, showFolderPath)\n\n//   const seasons = await Promise.all(\n//     seasonsResponse.map(async (seasonResponse) => {\n//       const number = Number.parseInt(seasonResponse.name)\n//       if (isNaN(number)) return\n\n//       return {\n//         number,\n//         episodes: await indexEpisodes(\n//           providerId,\n//           client,\n//           `${showFolderPath}/${seasonResponse.name}`,\n//         ),\n//       }\n//     }),\n//   )\n\n//   return seasons.filter(notUndefined)\n// }\n\n// const indexShows = async (\n//   providerId: string,\n//   client: Client,\n//   path: string | undefined,\n// ): Promise<ShowIndexResponse[]> => {\n//   if (path === undefined) return []\n\n//   const showsResponse = await fetchItems(client, path)\n\n//   return Promise.all(\n//     showsResponse.map(async (showResponse) => ({\n//       name: showResponse.name,\n//       seasons: await indexSeasons(\n//         providerId,\n//         client,\n//         `${path}/${showResponse.name}`,\n//       ),\n//     })),\n//   )\n// }\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const index = async (provider: FTP): Promise<IndexResponse> => {\n  return {\n    movies: [],\n    shows: [],\n  }\n\n  // const client = await getClient(\n  //   provider.host,\n  //   provider.port,\n  //   provider.username,\n  //   provider.password,\n  //   provider.secure,\n  // )\n\n  // return {\n  //   movies: await indexMovies(provider.id, client, provider.moviesPath),\n  //   shows: await indexShows(provider.id, client, provider.showsPath),\n  // }\n}\n","import { DriveItemChildrenResponse, DriveItemResponse } from './types'\nimport { Client } from '@microsoft/microsoft-graph-client'\n\nexport const getClient = (accessToken: string) =>\n  Client.init({\n    authProvider: (done) => done(null, accessToken),\n  })\n\nexport const fetchPathChildren = (\n  client: Client,\n  path: string,\n): Promise<DriveItemChildrenResponse> =>\n  client.api(`/me/drive/root:${path}:/children`).get()\n\nexport const fetchItem = (\n  client: Client,\n  itemId: string,\n): Promise<DriveItemResponse> => client.api(`/me/drive/items/${itemId}`).get()\n\nexport const fetchItemChildren = (\n  client: Client,\n  itemId: string,\n): Promise<DriveItemChildrenResponse> =>\n  client.api(`/me/drive/items/${itemId}/children`).get()\n","import { Caption, CaptionType } from '../../../types/files/Caption'\nimport { DriveItemResponse, FileResponse, VideoResponse } from './types'\nimport { File, FileKind } from '../../../types/files/File'\nimport { Video, VideoType } from '../../../types/files/Video'\nimport {\n  buildFileId,\n  parseCaptionType,\n  parseFileName,\n  parseVideoType,\n} from '../util'\nimport { ProviderKind } from '../../../types/providers/Provider'\n\nconst buildCaption = (\n  providerId: string,\n  type: CaptionType,\n  name: string,\n  {\n    id,\n    name: fileName,\n    size,\n    webUrl,\n    '@microsoft.graph.downloadUrl': downloadUrl,\n  }: DriveItemResponse,\n  { mimeType }: FileResponse,\n): Caption => ({\n  kind: FileKind.Caption,\n  type,\n  id: buildFileId(ProviderKind.OneDrive, id),\n  name,\n  provider: {\n    kind: ProviderKind.OneDrive,\n    providerId,\n    id,\n    fileName,\n    size,\n    downloadUrl,\n    webUrl,\n    mimeType,\n  },\n})\n\nconst buildVideo = (\n  providerId: string,\n  type: VideoType,\n  name: string,\n  {\n    id,\n    name: fileName,\n    size,\n    webUrl,\n    '@microsoft.graph.downloadUrl': downloadUrl,\n  }: DriveItemResponse,\n  { mimeType }: FileResponse,\n  {\n    bitrate,\n    duration,\n    height,\n    width,\n    audioChannels,\n    audioFormat,\n    fourCC,\n    frameRate,\n  }: VideoResponse,\n): Video => ({\n  kind: FileKind.Video,\n  type,\n  id: buildFileId(ProviderKind.OneDrive, id),\n  name,\n  provider: {\n    kind: ProviderKind.OneDrive,\n    providerId,\n    id,\n    fileName,\n    size,\n    downloadUrl,\n    webUrl,\n    mimeType,\n    bitrate,\n    duration,\n    height,\n    width,\n    audioChannels,\n    audioFormat,\n    fourCC,\n    frameRate,\n  },\n})\n\nexport const buildFile =\n  (providerId: string) =>\n  (response: DriveItemResponse): File | undefined => {\n    if (response.file === undefined) return\n\n    const { name, extension } = parseFileName(response.name)\n    if (extension === undefined) return\n\n    const captionType = parseCaptionType(extension)\n    const videoType = parseVideoType(extension)\n\n    if (captionType !== undefined)\n      return buildCaption(\n        providerId,\n        captionType,\n        name,\n        response,\n        response.file,\n      )\n    else if (videoType !== undefined && response.video !== undefined)\n      return buildVideo(\n        providerId,\n        videoType,\n        name,\n        response,\n        response.file,\n        response.video,\n      )\n  }\n","import {\n  CaptionProvider,\n  IFTPFileProvider,\n  IOneDriveFileProvider,\n} from './FileProvider'\nimport { FileKind, IFile } from './File'\n\nexport const VTT_EXTENSION = 'vtt'\n\nexport type CaptionType = typeof VTT_EXTENSION\n\nexport interface Caption extends IFile<CaptionProvider> {\n  kind: typeof FileKind.Caption\n  type: CaptionType\n}\n\nexport type FTPCaption = IFTPFileProvider\n\nexport type OneDriveCaption = IOneDriveFileProvider\n","import {\n  EpisodeIndexResponse,\n  IndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n  ShowIndexResponse,\n} from '../types'\nimport {\n  fetchItem,\n  fetchItemChildren,\n  fetchPathChildren,\n  getClient,\n} from './api'\nimport { CannotFindFileError } from '../../../errors/CannotFindFileError'\nimport { Client } from '@microsoft/microsoft-graph-client'\nimport { File } from '../../../types/files/File'\nimport { OneDrive } from '../../../types/providers/OneDrive'\nimport { ProviderKind } from '../../../types/providers/Provider'\nimport { buildFile } from './util'\nimport { notUndefined } from '../../../util'\n\nexport const updateFile = async (\n  provider: OneDrive,\n  file: File,\n): Promise<File> => {\n  const client = getClient(provider.accessToken.token)\n  if (file.provider.kind !== ProviderKind.OneDrive)\n    throw new Error(\n      'Internal error: attempted to update file with the wrong provider.',\n    )\n  const response = await fetchItem(client, file.provider.id)\n  const newFile = buildFile(provider.id)(response)\n\n  if (newFile !== undefined) return newFile\n  else throw new CannotFindFileError(file)\n}\n\nconst indexFiles = async (\n  providerId: string,\n  client: Client,\n  folderId: string,\n): Promise<File[]> => {\n  const { value: filesResponse } = await fetchItemChildren(client, folderId)\n\n  return filesResponse.map(buildFile(providerId)).filter(notUndefined)\n}\n\nconst indexMovies = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<MovieIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const { value: moviesResponse } = await fetchPathChildren(client, path)\n\n  return Promise.all(\n    moviesResponse.map(async (movieResponse) => ({\n      name: movieResponse.name,\n      files: await indexFiles(providerId, client, movieResponse.id),\n    })),\n  )\n}\n\nconst indexEpisodes = async (\n  providerId: string,\n  client: Client,\n  seasonFolderId: string,\n): Promise<EpisodeIndexResponse[]> => {\n  const { value: episodesResponse } = await fetchItemChildren(\n    client,\n    seasonFolderId,\n  )\n\n  const episodes = await Promise.all(\n    episodesResponse.map(async (episodeResponse) => {\n      const number = Number.parseInt(episodeResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        files: await indexFiles(providerId, client, episodeResponse.id),\n      }\n    }),\n  )\n\n  return episodes.filter(notUndefined)\n}\n\nconst indexSeasons = async (\n  providerId: string,\n  client: Client,\n  showFolderId: string,\n): Promise<SeasonIndexResponse[]> => {\n  const { value: seasonsResponse } = await fetchItemChildren(\n    client,\n    showFolderId,\n  )\n\n  const seasons = await Promise.all(\n    seasonsResponse.map(async (seasonResponse) => {\n      const number = Number.parseInt(seasonResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        episodes: await indexEpisodes(providerId, client, seasonResponse.id),\n      }\n    }),\n  )\n\n  return seasons.filter(notUndefined)\n}\n\nconst indexShows = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<ShowIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const { value: showsResponse } = await fetchPathChildren(client, path)\n\n  return Promise.all(\n    showsResponse.map(async (showResponse) => ({\n      name: showResponse.name,\n      seasons: await indexSeasons(providerId, client, showResponse.id),\n    })),\n  )\n}\n\nexport const index = async (provider: OneDrive): Promise<IndexResponse> => {\n  const client = getClient(provider.accessToken.token)\n\n  return {\n    movies: await indexMovies(provider.id, client, provider.moviesPath),\n    shows: await indexShows(provider.id, client, provider.showsPath),\n  }\n}\n","import {\n  EpisodeIndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n} from './types'\nimport { File, FileKind } from '../../types/files/File'\nimport { Provider, ProviderKind } from '../../types/providers/Provider'\nimport { Caption } from '../../types/files/Caption'\nimport { EpisodeLike } from '../../types/items/Episode'\nimport { ItemKind } from '../../types/items/Item'\nimport { MovieLike } from '../../types/items/Movie'\nimport { SeasonLike } from '../../types/items/Season'\nimport { ShowLike } from '../../types/items/Show'\nimport { Video } from '../../types/files/Video'\nimport { updateFile as ftpUpdateFile } from './FTP'\nimport { updateFile as oneDriveUpdateFile } from './OneDrive'\n\nconst isCaption = (file: File): file is Caption =>\n  file.kind === FileKind.Caption\n\nconst isVideo = (file: File): file is Video => file.kind === FileKind.Video\n\nexport const buildEpisodeLike =\n  (showTmdbId: number, seasonNumber: number) =>\n  (item: EpisodeIndexResponse): EpisodeLike => ({\n    kind: ItemKind.Episode,\n    number: item.number,\n    seasonNumber,\n    showTmdbId,\n    sources: item.files.filter(isVideo),\n    captions: item.files.filter(isCaption),\n    usage: {\n      lastWatched: undefined,\n      progress: undefined,\n    },\n  })\n\nexport const buildMovieLike =\n  (tmdbId: number) =>\n  (item: MovieIndexResponse): MovieLike => ({\n    kind: ItemKind.Movie,\n    tmdbId,\n    sources: item.files.filter(isVideo),\n    captions: item.files.filter(isCaption),\n    usage: {\n      lastWatched: undefined,\n      progress: undefined,\n    },\n  })\n\nexport const buildSeasonLike =\n  (showTmdbId: number) =>\n  (item: SeasonIndexResponse): SeasonLike => ({\n    kind: ItemKind.Season,\n    number: item.number,\n    showTmdbId,\n    usage: {\n      lastWatched: undefined,\n      progress: undefined,\n    },\n  })\n\nexport const buildShowLike = (tmdbId: number) => (): ShowLike => ({\n  kind: ItemKind.Show,\n  tmdbId,\n  usage: {\n    lastWatched: undefined,\n    progress: undefined,\n  },\n})\n\nexport const updateFile = (provider: Provider, file: File): Promise<File> => {\n  switch (provider.kind) {\n    case ProviderKind.FTP:\n      return ftpUpdateFile(provider, file)\n    case ProviderKind.OneDrive:\n      return oneDriveUpdateFile(provider, file)\n  }\n}\n","import { Episode, EpisodeLike } from '../types/items/Episode'\nimport {\n  EpisodeIndexResponse,\n  IndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n  ShowIndexResponse,\n} from './drives/types'\nimport { Movie, MovieLike } from '../types/items/Movie'\nimport { Provider, ProviderKind } from '../types/providers/Provider'\nimport { Season, SeasonLike } from '../types/items/Season'\nimport { Show, ShowLike } from '../types/items/Show'\nimport {\n  buildEpisodeIndexResponse,\n  buildSeasonIndexResponse,\n} from './drives/util'\nimport {\n  buildEpisodeLike,\n  buildMovieLike,\n  buildSeasonLike,\n  buildShowLike,\n} from './drives'\nimport { findMovie, findShow } from './databases/TMDb/api'\nimport { index as ftpIndex } from '../services/drives/FTP'\nimport { index as oneDriveIndex } from '../services/drives/OneDrive'\n\nconst handleProvider = (provider: Provider): Promise<IndexResponse> => {\n  switch (provider.kind) {\n    case ProviderKind.FTP:\n      return ftpIndex(provider)\n    case ProviderKind.OneDrive:\n      return oneDriveIndex(provider)\n  }\n}\n\nconst indexMovies = (\n  moviesResponse: MovieIndexResponse[],\n  fetchMovieMetadata: (movie: MovieLike) => Promise<Movie>,\n) =>\n  Promise.all(\n    moviesResponse.map(async (movieResponse) => {\n      const tmdbId = await findMovie(movieResponse.name)\n      if (tmdbId === undefined) return\n\n      const movieAlike = buildMovieLike(tmdbId)(movieResponse)\n      await fetchMovieMetadata(movieAlike)\n    }),\n  )\n\nconst indexShows = (\n  showsResponse: ShowIndexResponse[],\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n  fetchShowMetadata: (show: ShowLike) => Promise<Show>,\n) =>\n  Promise.all(\n    showsResponse.map(async (showResponse) => {\n      const tmdbId = await findShow(showResponse.name)\n      if (tmdbId === undefined) return\n\n      const showAlike = buildShowLike(tmdbId)()\n      const show = await fetchShowMetadata(showAlike)\n      await indexSeasons(\n        show.seasons.map((number) =>\n          buildSeasonIndexResponse(\n            number,\n            showResponse.seasons.find((season) => season.number === number)\n              ?.episodes,\n          ),\n        ),\n        show,\n        fetchEpisodeMetadata,\n        fetchSeasonMetadata,\n      )\n    }),\n  )\n\nconst indexSeasons = (\n  seasonsResponse: SeasonIndexResponse[],\n  show: Show,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n) =>\n  Promise.all(\n    seasonsResponse.map(async (seasonResponse) => {\n      const seasonAlike = buildSeasonLike(show.tmdbId)(seasonResponse)\n      const season = await fetchSeasonMetadata(show, seasonAlike)\n      await indexEpisodes(\n        season.episodes.map((number) =>\n          buildEpisodeIndexResponse(\n            number,\n            seasonResponse.episodes.find((episode) => episode.number === number)\n              ?.files,\n          ),\n        ),\n        show,\n        season,\n        fetchEpisodeMetadata,\n      )\n    }),\n  )\n\nconst indexEpisodes = (\n  episodesResponse: EpisodeIndexResponse[],\n  show: Show,\n  season: Season,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n) =>\n  Promise.all(\n    episodesResponse.map(async (episodeResponse) => {\n      const episodeAlike = buildEpisodeLike(\n        show.tmdbId,\n        season.number,\n      )(episodeResponse)\n      await fetchEpisodeMetadata(show.id, season.id, episodeAlike)\n    }),\n  )\n\nexport const index = async (\n  provider: Provider,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchMovieMetadata: (movie: MovieLike) => Promise<Movie>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n  fetchShowMetadata: (show: ShowLike) => Promise<Show>,\n) => {\n  const { movies: moviesResponse, shows: showsResponse } =\n    await handleProvider(provider)\n\n  await indexMovies(moviesResponse, fetchMovieMetadata)\n  await indexShows(\n    showsResponse,\n    fetchEpisodeMetadata,\n    fetchSeasonMetadata,\n    fetchShowMetadata,\n  )\n}\n","import { Episode, EpisodeLike } from '../types/items/Episode'\nimport { Movie, MovieLike } from '../types/items/Movie'\nimport { Season, SeasonLike } from '../types/items/Season'\nimport { Show, ShowLike } from '../types/items/Show'\nimport { addPerson, resetPeople } from './people/actions'\nimport { episodeSelector, episodesSelector } from './episodes/selectors'\nimport {\n  fetchEpisodeMetadata as fetchEpisodeMetadataCall,\n  fetchMovieMetadata as fetchMovieMetadataCall,\n  fetchSeasonMetadata as fetchSeasonMetadataCall,\n  fetchShowMetadata as fetchShowMetadataCall,\n} from '../services/databases/TMDb'\nimport { movieSelector, moviesSelector } from './movies/selectors'\nimport { seasonSelector, seasonsSelector } from './seasons/selectors'\nimport { showSelector, showsSelector } from './shows/selectors'\nimport { AppThunk } from '.'\nimport { Caption } from '../types/files/Caption'\nimport { File } from '../types/files/File'\nimport { ItemKind } from '../types/items/Item'\nimport { Person } from '../types/items/Person'\nimport { Provider } from '../types/providers/Provider'\nimport { Video } from '../types/files/Video'\nimport { auth as authCall } from './auth/thunks'\nimport { removeFilesByProvider as episodeRemoveFilesByProvider } from './episodes/thunks'\nimport { index as indexCall } from '../services/indexing'\nimport { removeFilesByProvider as movieRemoveFilesByProvider } from './movies/thunks'\nimport { providerSelector } from './auth/selectors'\nimport { removeProvider as removeProviderAction } from './auth/actions'\nimport { updateEpisode } from './episodes/actions'\nimport { updateFile as updateFileCall } from '../services/drives'\nimport { updateMovie } from './movies/actions'\nimport { updateSeason } from './seasons/actions'\nimport { updateShow } from './shows/actions'\n\nexport const index =\n  (providers: Provider[]): AppThunk<Promise<void>> =>\n  async (dispatch) => {\n    dispatch(resetPeople())\n\n    await Promise.all(\n      providers.map(async (provider) => {\n        const updatedProvider = await dispatch(authCall(provider))\n        if (updatedProvider === undefined)\n          throw new Error(\n            'cannot sign in using the redirect flow while updating files',\n          )\n\n        await indexCall(\n          updatedProvider,\n          (showId: string, seasonId: string, episode: EpisodeLike) =>\n            dispatch(fetchEpisodeMetadata(showId, seasonId, episode)),\n          (movie: MovieLike) => dispatch(fetchMovieMetadata(movie)),\n          (show: Show, season: SeasonLike) =>\n            dispatch(fetchSeasonMetadata(show, season)),\n          (show: ShowLike) => dispatch(fetchShowMetadata(show)),\n        )\n      }),\n    )\n  }\n\nconst updateFile =\n  (file: File): AppThunk<Promise<File>> =>\n  async (dispatch, getState) => {\n    const { auth } = getState()\n    const provider = providerSelector(file.provider.providerId)(auth)\n    if (provider === undefined)\n      throw new Error('could not find provider for file')\n\n    const updatedProvider = await dispatch(authCall(provider))\n    if (updatedProvider === undefined)\n      throw new Error(\n        'cannot sign in using the redirect flow while updating files',\n      )\n\n    const updatedFile = await updateFileCall(updatedProvider, file)\n\n    return updatedFile\n  }\n\nconst handleUpdateWatchableItem =\n  (item: Episode | Movie): AppThunk<void> =>\n  async (dispatch) => {\n    switch (item.kind) {\n      case ItemKind.Episode:\n        return dispatch(updateEpisode(item))\n      case ItemKind.Movie:\n        return dispatch(updateMovie(item))\n    }\n  }\n\nexport const updateFiles =\n  (item: Episode | Movie): AppThunk<Promise<Episode | Movie>> =>\n  async (dispatch) => {\n    const sources = await Promise.all(\n      item.sources.map(\n        (source) => dispatch(updateFile(source)) as Promise<Video>,\n      ),\n    )\n    const captions = await Promise.all(\n      item.captions.map(\n        (caption) => dispatch(updateFile(caption)) as Promise<Caption>,\n      ),\n    )\n    const updatedItem = {\n      ...item,\n      sources,\n      captions,\n    }\n\n    dispatch(handleUpdateWatchableItem(updatedItem))\n    return updatedItem\n  }\n\nconst handleNewPeople =\n  ({ cast, crew }: { cast: Person[]; crew: Person[] }): AppThunk<void> =>\n  async (dispatch) =>\n    cast.concat(crew).forEach((person) => dispatch(addPerson(person.id)))\n\nconst fetchEpisodeMetadata =\n  (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ): AppThunk<Promise<Episode>> =>\n  async (dispatch, getState) => {\n    const { episodes } = getState()\n\n    const newEpisode = await fetchEpisodeMetadataCall(showId, seasonId, episode)\n    const oldEpisode = episodeSelector(newEpisode.id)(episodes)\n    if (oldEpisode !== undefined) newEpisode.usage = oldEpisode.usage\n\n    dispatch(updateEpisode(newEpisode))\n    return newEpisode\n  }\n\nconst fetchMovieMetadata =\n  (movie: MovieLike): AppThunk<Promise<Movie>> =>\n  async (dispatch, getState) => {\n    const { movies } = getState()\n\n    const newMovie = await fetchMovieMetadataCall(movie)\n    const oldMovie = movieSelector(newMovie.id)(movies)\n    if (oldMovie !== undefined) newMovie.usage = oldMovie.usage\n\n    dispatch(updateMovie(newMovie))\n    dispatch(handleNewPeople(newMovie))\n    return newMovie\n  }\n\nconst fetchSeasonMetadata =\n  (show: Show, season: SeasonLike): AppThunk<Promise<Season>> =>\n  async (dispatch, getState) => {\n    const { seasons } = getState()\n\n    const newSeason = await fetchSeasonMetadataCall(show, season)\n    const oldSeason = seasonSelector(newSeason.id)(seasons)\n    if (oldSeason !== undefined) newSeason.usage = oldSeason.usage\n\n    dispatch(updateSeason(newSeason))\n    dispatch(handleNewPeople(newSeason))\n    return newSeason\n  }\n\nconst fetchShowMetadata =\n  (show: ShowLike): AppThunk<Promise<Show>> =>\n  async (dispatch, getState) => {\n    const { shows } = getState()\n\n    const newShow = await fetchShowMetadataCall(show)\n    const oldShow = showSelector(newShow.id)(shows)\n    if (oldShow !== undefined) newShow.usage = oldShow.usage\n\n    dispatch(updateShow(newShow))\n    return newShow\n  }\n\nconst fetchEpisodesMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { episodes } = getState()\n\n    await Promise.all(\n      episodesSelector(episodes).map(async (episode) =>\n        dispatch(\n          fetchEpisodeMetadata(episode.showId, episode.seasonId, episode),\n        ),\n      ),\n    )\n  }\n\nconst fetchMoviesMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { movies } = getState()\n\n    await Promise.all(\n      moviesSelector(movies).map(async (movie) =>\n        dispatch(fetchMovieMetadata(movie)),\n      ),\n    )\n  }\n\nconst fetchSeasonsMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { seasons, shows } = getState()\n\n    await Promise.all(\n      seasonsSelector(seasons).map(async (season) => {\n        const show = showSelector(season.showId)(shows)\n        if (show === undefined) throw new Error('cannot find show for season')\n\n        return dispatch(fetchSeasonMetadata(show, season))\n      }),\n    )\n  }\n\nconst fetchShowsMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { shows } = getState()\n\n    await Promise.all(\n      showsSelector(shows).map(async (show) =>\n        dispatch(fetchShowMetadata(show)),\n      ),\n    )\n  }\n\nexport const fetchAllMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch) => {\n    dispatch(resetPeople())\n\n    await dispatch(fetchMoviesMetadata())\n    await dispatch(fetchShowsMetadata())\n    await dispatch(fetchSeasonsMetadata())\n    await dispatch(fetchEpisodesMetadata())\n  }\n\nexport const removeProvider =\n  (id: string): AppThunk<void> =>\n  (dispatch, getState) => {\n    dispatch(removeProviderAction(id))\n\n    const { episodes, movies } = getState()\n    episodesSelector(episodes).forEach((episode) =>\n      dispatch(episodeRemoveFilesByProvider(episode, id)),\n    )\n    moviesSelector(movies).forEach((movie) =>\n      dispatch(movieRemoveFilesByProvider(movie, id)),\n    )\n  }\n"],"names":["Modal","isActive","onClose","children","modalRef","useRef","useOnClickOutside","className","classNames","active","ref","useModal","useState","show","setShow","useCallback","updateEpisode","episode","type","UPDATE_EPISODE","payload","episodeSelector","id","state","episodesSelector","Object","keys","map","episodesBySeasonSelector","seasonId","createSelector","episodes","filter","updateSeasonProgress","season","progress","dispatch","getState","usage","lastWatched","Date","toISOString","updateSeason","shows","showSelector","showId","undefined","Error","updateShow","updateShowProgress","number","updateEpisodeProgress","seasons","seasonSelector","updateMovie","movie","UPDATE_MOVIE","movieSelector","moviesSelector","inProgressSelector","isInProgress","recentlyWatchedSelector","wasRecentlyWatched","RECENTLY_WATCHED_THRESHOLD","moviesByPersonSelector","movies","cast","find","person","crew","moviesPersonSelector","fn","reduce","acc","people","concat","UPDATE_SEASON","seasonsSelector","seasonsByShowSelector","seasonsByPersonSelector","seasonsPersonSelector","UPDATE_SHOW","showsSelector","HttpMethod","resetPeople","RESET_PEOPLE","FileKind","buildUrl","baseUrl","path","params","url","URL","entries","key","value","searchParams","append","http","method","accessToken","fetch","href","headers","Authorization","Accept","response","text","body","JSON","parse","ok","APIError","status","statusText","get","GET","BASE_URL","ACCESS_TOKEN","process","findMovie","query","language","i18next","results","length","findShow","fetchMovieCredits","fetchSeasonCredits","seasonNumber","fetchEpisode","episodeNumber","fetchEpisodeMetadata","showTmdbId","buildEpisode","fetchMovieMetadata","tmdbId","creditsResponse","buildMovie","fetchSeasonMetadata","buildSeason","fetchShowMetadata","buildShow","buildFileId","kind","buildEpisodeIndexResponse","files","buildSeasonIndexResponse","updateFile","provider","file","CannotFindFileError","index","getClient","Client","init","authProvider","done","fetchPathChildren","client","api","fetchItem","itemId","fetchItemChildren","buildFile","providerId","fileName","name","split","shift","extension","pop","captionType","parseCaptionType","videoType","MP4_EXTENSION","M4V_EXTENSION","MKV_EXTENSION","WEBM_EXTENSION","parseVideoType","size","webUrl","downloadUrl","mimeType","Caption","ProviderKind","OneDrive","buildCaption","video","bitrate","duration","height","width","audioChannels","audioFormat","fourCC","frameRate","Video","buildVideo","token","newFile","indexFiles","folderId","filesResponse","notUndefined","indexMovies","moviesResponse","Promise","all","movieResponse","indexEpisodes","seasonFolderId","episodesResponse","episodeResponse","Number","parseInt","isNaN","indexSeasons","showFolderId","seasonsResponse","seasonResponse","indexShows","showsResponse","showResponse","moviesPath","showsPath","isCaption","isVideo","buildEpisodeLike","item","ItemKind","Episode","sources","captions","buildMovieLike","Movie","buildSeasonLike","Season","buildShowLike","Show","FTP","ftpUpdateFile","oneDriveUpdateFile","handleProvider","ftpIndex","oneDriveIndex","movieAlike","showAlike","seasonAlike","episodeAlike","providers","authCall","updatedProvider","indexCall","auth","providerSelector","updateFileCall","updatedFile","handleUpdateWatchableItem","updateFiles","source","caption","updatedItem","handleNewPeople","forEach","ADD_PERSON","fetchEpisodeMetadataCall","newEpisode","oldEpisode","fetchMovieMetadataCall","newMovie","oldMovie","fetchSeasonMetadataCall","newSeason","oldSeason","fetchShowMetadataCall","newShow","oldShow","fetchAllMetadata"],"sourceRoot":""}