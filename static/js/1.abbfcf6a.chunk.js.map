{"version":3,"sources":["store/movies/selectors.ts","store/shows/selectors.ts","store/seasons/selectors.ts","store/auth/actions.ts","store/auth/selectors.ts","store/ui/thunks.ts","errors/index.ts","store/episodes/selectors.ts","services/http.ts","types/files/File.ts","services/databases/TMDb/api.ts","services/databases/TMDb/index.ts","services/drives/OneDrive/api.ts","services/drives/util.ts","services/drives/OneDrive/util.ts","types/files/captions/Caption.ts","services/drives/OneDrive/index.ts","services/drives/index.tsx","services/indexing.ts","store/thunks.ts","services/auth/OneDrive.ts","services/auth/util.ts","store/auth/thunks.ts","errors/APIError.ts","errors/AuthenticationFailure.ts","errors/ProviderAlreadyExists.ts","store/episodes/actions.ts","store/seasons/actions.ts","store/shows/actions.ts","errors/CannotFindFileError.ts","store/movies/thunks.ts","store/movies/actions.ts","store/seasons/thunks.ts","store/shows/thunks.ts","store/episodes/thunks.ts"],"names":["movieSelector","id","state","moviesSelector","Object","keys","map","inProgressSelector","filter","isInProgress","recentlyWatchedSelector","movie","wasRecentlyWatched","RECENTLY_WATCHED_THRESHOLD","moviesByPersonSelector","createSelector","movies","cast","find","person","crew","moviesPersonSelector","fn","reduce","acc","people","concat","showSelector","showsSelector","seasonSelector","seasonsSelector","season","seasonsByShowSelector","showId","seasons","seasonsByPersonSelector","seasonsPersonSelector","expectLoginRedirect","provider","type","EXPECT_LOGIN_REDIRECT","payload","expectSetupRedirect","kind","EXPECT_SETUP_REDIRECT","handledRedirect","HANDLED_REDIRECT","updateProvider","UPDATE_PROVIDER","removeProvider","REMOVE_PROVIDER","providerSelector","providers","providersSelector","load","dispatch","a","asyncBegin","result","console","error","Error","addNotification","APIError","NotificationKind","status","message","AuthenticationFailure","CannotFindFileError","CannotFindFile","file","ProviderAlreadyExists","GenericError","asyncEnd","episodeSelector","episodesSelector","episodesBySeasonSelector","seasonId","episodes","episode","HttpMethod","FileKind","buildUrl","baseUrl","path","params","url","URL","undefined","entries","key","value","searchParams","append","http","method","accessToken","fetch","href","headers","Authorization","Accept","response","text","body","JSON","parse","ok","statusText","get","GET","BASE_URL","ACCESS_TOKEN","process","findMovie","query","language","i18next","results","length","findShow","fetchMovieCredits","fetchSeasonCredits","seasonNumber","fetchEpisode","episodeNumber","fetchEpisodeMetadata","showTmdbId","number","buildEpisode","fetchMovieMetadata","tmdbId","creditsResponse","buildMovie","fetchSeasonMetadata","show","buildSeason","fetchShowMetadata","buildShow","getClient","Client","init","authProvider","done","fetchPathChildren","client","api","fetchItem","itemId","fetchItemChildren","buildFileId","buildFile","providerId","fileName","name","split","shift","extension","pop","captionType","parseCaptionType","videoType","MP4_EXTENSION","M4V_EXTENSION","MKV_EXTENSION","WEBM_EXTENSION","parseVideoType","size","webUrl","downloadUrl","mimeType","Caption","ProviderKind","OneDrive","buildCaption","video","bitrate","duration","height","width","audioChannels","audioFormat","fourCC","frameRate","Video","buildVideo","updateFile","newFile","indexFiles","folderId","filesResponse","notUndefined","indexMovies","moviesResponse","Promise","all","movieResponse","files","indexEpisodes","seasonFolderId","episodesResponse","episodeResponse","Number","parseInt","isNaN","indexSeasons","showFolderId","seasonsResponse","seasonResponse","indexShows","showsResponse","showResponse","index","moviesPath","showsPath","shows","isCaption","isVideo","buildEpisodeLike","item","ItemKind","Episode","sources","captions","usage","lastWatched","progress","buildMovieLike","Movie","buildSeasonLike","Season","buildShowLike","Show","oneDriveUpdateFile","token","handleProvider","oneDriveIndex","movieAlike","showAlike","seasonAlike","episodeAlike","authCall","updatedProvider","indexCall","getState","auth","updateFileCall","updatedFile","handleUpdateWatchableItem","updateEpisode","updateMovie","updateFiles","source","caption","updatedItem","fetchEpisodeMetadataCall","newEpisode","oldEpisode","fetchMovieMetadataCall","newMovie","oldMovie","fetchSeasonMetadataCall","newSeason","oldSeason","updateSeason","fetchShowMetadataCall","newShow","oldShow","updateShow","fetchAllMetadata","CLIENT_ID","SCOPES","buildAuthResponse","account","expiresOn","validUntil","toISOString","username","silentLogIn","app","acquireTokenSilent","scopes","newAccount","popupLogIn","loginPopup","redirectLogIn","loginRedirect","interactiveLogIn","onRedirect","isMobile","performAuth","InteractionRequiredAuthError","Date","PublicClientApplication","clientId","authHandleRedirect","log","window","location","hash","handleRedirectPromise","authHandleProvider","oneDriveAuthCall","setupAuthHandleProvider","authHandleRedirectHandleProvider","oneDriveAuthHandleRedirectCall","authHandleResponse","setupAuthHandleResponse","_","setupAuth","cache","setupAuthHandleRedirect","captureStackTrace","UPDATE_EPISODE","UPDATE_SEASON","UPDATE_SHOW","updateMovieProgress","removeFilesByProvider","UPDATE_MOVIE","updateSeasonProgress","updateShowProgress","updateEpisodeProgress"],"mappings":"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","file":"static/js/1.abbfcf6a.chunk.js","sourcesContent":["import { isInProgress, wasRecentlyWatched } from '../../util'\nimport { Movie } from '../../types/items/Movie'\nimport { MoviesState } from './types'\nimport { Person } from '../../types/items/Person'\nimport { RECENTLY_WATCHED_THRESHOLD } from '../../constants'\nimport { createSelector } from 'reselect'\n\nexport const movieSelector = (id: string) => (state: MoviesState) => state[id]\n\nexport const moviesSelector = (state: MoviesState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const inProgressSelector = (state: MoviesState) =>\n  moviesSelector(state).filter(isInProgress)\n\nexport const recentlyWatchedSelector = (state: MoviesState) =>\n  moviesSelector(state).filter((movie) =>\n    wasRecentlyWatched(movie, RECENTLY_WATCHED_THRESHOLD),\n  )\n\nexport const moviesByPersonSelector = (id: string) =>\n  createSelector(moviesSelector, (movies) =>\n    movies.filter(\n      (movie) =>\n        movie.cast.find((person) => person.id === id) ||\n        movie.crew.find((person) => person.id === id),\n    ),\n  )\n\nexport const moviesPersonSelector = (\n  id: string,\n  fn: (movie: Movie) => Person[],\n) =>\n  createSelector(moviesSelector, (movies) =>\n    movies\n      .map(fn)\n      .reduce((acc, people) => acc.concat(people), [])\n      .filter((person) => person.id === id),\n  )\n","import { ShowsState } from './types'\n\nexport const showSelector = (id: string) => (state: ShowsState) => state[id]\n\nexport const showsSelector = (state: ShowsState) =>\n  Object.keys(state).map((id) => state[id]!)\n","import { isInProgress, wasRecentlyWatched } from '../../util'\nimport { Person } from '../../types/items/Person'\nimport { RECENTLY_WATCHED_THRESHOLD } from '../../constants'\nimport { Season } from '../../types/items/Season'\nimport { SeasonsState } from './types'\nimport { createSelector } from 'reselect'\n\nexport const seasonSelector = (id: string) => (state: SeasonsState) => state[id]\n\nexport const seasonsSelector = (state: SeasonsState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const inProgressSelector = (state: SeasonsState) =>\n  seasonsSelector(state).filter(isInProgress)\n\nexport const recentlyWatchedSelector = (state: SeasonsState) =>\n  seasonsSelector(state).filter((season) =>\n    wasRecentlyWatched(season, RECENTLY_WATCHED_THRESHOLD),\n  )\n\nexport const seasonsByShowSelector = (showId: string) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons.filter((season) => season.showId === showId),\n  )\n\nexport const seasonsByPersonSelector = (id: string) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons.filter(\n      (season) =>\n        season.cast.find((person) => person.id === id) ||\n        season.crew.find((person) => person.id === id),\n    ),\n  )\n\nexport const seasonsPersonSelector = (\n  id: string,\n  fn: (season: Season) => Person[],\n) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons\n      .map(fn)\n      .reduce((acc, people) => acc.concat(people), [])\n      .filter((person) => person.id === id),\n  )\n","import {\n  AuthActionTypes,\n  EXPECT_LOGIN_REDIRECT,\n  EXPECT_SETUP_REDIRECT,\n  HANDLED_REDIRECT,\n  REMOVE_PROVIDER,\n  UPDATE_PROVIDER,\n  UPDATE_VERSION,\n} from './types'\nimport {\n  Provider,\n  ProviderKindWithRedirect,\n} from '../../types/providers/Provider'\n\nexport const expectLoginRedirect = (provider: Provider): AuthActionTypes => ({\n  type: EXPECT_LOGIN_REDIRECT,\n  payload: {\n    provider,\n  },\n})\n\nexport const expectSetupRedirect = (\n  kind: ProviderKindWithRedirect,\n): AuthActionTypes => ({\n  type: EXPECT_SETUP_REDIRECT,\n  payload: {\n    kind,\n  },\n})\n\nexport const handledRedirect = (): AuthActionTypes => ({\n  type: HANDLED_REDIRECT,\n})\n\nexport const updateProvider = (provider: Provider): AuthActionTypes => ({\n  type: UPDATE_PROVIDER,\n  payload: {\n    provider,\n  },\n})\n\nexport const updateVersion = (version: string): AuthActionTypes => ({\n  type: UPDATE_VERSION,\n  payload: { version },\n})\n\nexport const removeProvider = (id: string): AuthActionTypes => ({\n  type: REMOVE_PROVIDER,\n  payload: { id },\n})\n","import { AuthState } from './types'\n\nexport const providerSelector = (id: string) => (state: AuthState) =>\n  state.providers[id]\n\nexport const providersSelector = (state: AuthState) =>\n  Object.keys(state.providers).map((id) => state.providers[id]!)\n","import { addNotification, asyncBegin, asyncEnd } from './actions'\nimport { AppThunk } from '../index'\nimport { handleError } from '../../errors'\n\nexport const load = <ReturnType>(\n  fn: AppThunk<Promise<ReturnType>>,\n): AppThunk<Promise<ReturnType | undefined>> => async (dispatch) => {\n  dispatch(asyncBegin())\n\n  let result: ReturnType | undefined\n  try {\n    result = await dispatch(fn)\n  } catch (error: unknown) {\n    console.error(error) // eslint-disable-line no-console\n    if (error instanceof Error) {\n      dispatch(addNotification(handleError(error)))\n    }\n  }\n\n  dispatch(asyncEnd())\n\n  return result\n}\n","import { Notification, NotificationKind } from '../types/Notification'\nimport { APIError } from './APIError'\nimport { AuthenticationFailure } from './AuthenticationFailure'\nimport { CannotFindFileError } from './CannotFindFileError'\nimport { ProviderAlreadyExists } from './ProviderAlreadyExists'\n\nexport const handleError = (error: Error): Notification => {\n  if (error instanceof APIError) {\n    return {\n      kind: NotificationKind.APIError,\n      status: error.status,\n      message: error.message,\n    }\n  } else if (error instanceof AuthenticationFailure) {\n    return {\n      kind: NotificationKind.AuthenticationFailure,\n      provider: error.provider,\n    }\n  } else if (error instanceof CannotFindFileError) {\n    return { kind: NotificationKind.CannotFindFile, file: error.file }\n  } else if (error instanceof ProviderAlreadyExists) {\n    return {\n      kind: NotificationKind.ProviderAlreadyExists,\n      provider: error.provider,\n    }\n  } else {\n    return { kind: NotificationKind.GenericError, error }\n  }\n}\n","import { EpisodesState } from './types'\nimport { createSelector } from 'reselect'\n\nexport const episodeSelector = (id: string) => (state: EpisodesState) =>\n  state[id]\n\nexport const episodesSelector = (state: EpisodesState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const episodesBySeasonSelector = (seasonId: string) =>\n  createSelector(episodesSelector, (episodes) =>\n    episodes.filter((episode) => episode.seasonId === seasonId),\n  )\n","import { APIError } from '../errors/APIError'\n\nenum HttpMethod {\n  GET = 'GET',\n}\n\ntype Params = Record<string, string>\n\nconst buildUrl = (baseUrl: string, path: string, params?: Params) => {\n  const url = new URL(`${baseUrl}/${path}`)\n\n  if (params !== undefined)\n    for (const [key, value] of Object.entries(params))\n      url.searchParams.append(key, value)\n\n  return url\n}\n\nconst http = async <T>(\n  baseUrl: string,\n  path: string,\n  method: HttpMethod,\n  accessToken: string,\n  params?: Params,\n): Promise<T> => {\n  const response = await fetch(buildUrl(baseUrl, path, params).href, {\n    method,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n  })\n\n  // check if response is empty\n  // if empty just return an empty object\n  const text = await response.text()\n  const body = text ? JSON.parse(text) : {}\n\n  if (response.ok) return body\n  else throw new APIError(response.status, response.statusText)\n}\n\nexport const get = <T>(\n  baseUrl: string,\n  path: string,\n  accessToken: string,\n  params: Params,\n) => http<T>(baseUrl, path, HttpMethod.GET, accessToken, params)\n","import { Caption } from './captions/Caption'\nimport { FileProvider } from './FileProvider'\nimport { Video } from './videos/Video'\n\nexport enum FileKind {\n  Video,\n  Caption,\n}\n\nexport interface IFile<T extends FileProvider> {\n  kind: FileKind\n  id: string\n  name: string\n  provider: T\n}\n\nexport type File = Caption | Video\n","import {\n  MovieCreditsResponse,\n  MovieDetailsResponse,\n  SearchMoviesResponse,\n  SearchTVShowsResponse,\n  TVEpisodeResponse,\n  TVSeasonCreditsResponse,\n  TVSeasonDetailsResponse,\n  TVShowDetailsResponse,\n} from './types'\nimport { get } from '../../http'\nimport i18next from 'i18next'\n\nconst BASE_URL = 'https://api.themoviedb.org/3'\nconst ACCESS_TOKEN = process.env.REACT_APP_TMDB_API_READ_ACCESS_TOKEN!\n\nexport const findMovie = async (query: string) => {\n  const { results } = await get<SearchMoviesResponse>(\n    BASE_URL,\n    'search/movie',\n    ACCESS_TOKEN,\n    { language: i18next.language, query },\n  )\n\n  if (results.length === 0) return undefined\n  else return results[0].id\n}\n\nexport const findShow = async (query: string) => {\n  const { results } = await get<SearchTVShowsResponse>(\n    BASE_URL,\n    'search/tv',\n    ACCESS_TOKEN,\n    { language: i18next.language, query },\n  )\n\n  if (results.length === 0) return undefined\n  else return results[0].id\n}\n\nexport const fetchMovie = (id: number) =>\n  get<MovieDetailsResponse>(BASE_URL, `movie/${id}`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchMovieCredits = (id: number) =>\n  get<MovieCreditsResponse>(BASE_URL, `movie/${id}/credits`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchShow = (id: number) =>\n  get<TVShowDetailsResponse>(BASE_URL, `tv/${id}`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchSeason = (showId: number, seasonNumber: number) =>\n  get<TVSeasonDetailsResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n\nexport const fetchSeasonCredits = (showId: number, seasonNumber: number) =>\n  get<TVSeasonCreditsResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}/credits`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n\nexport const fetchEpisode = (\n  showId: number,\n  seasonNumber: number,\n  episodeNumber: number,\n) =>\n  get<TVEpisodeResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}/episode/${episodeNumber}`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n","import { Episode, EpisodeLike } from '../../../types/items/Episode'\nimport { Movie, MovieLike } from '../../../types/items/Movie'\nimport { Season, SeasonLike } from '../../../types/items/Season'\nimport { Show, ShowLike } from '../../../types/items/Show'\nimport { buildEpisode, buildMovie, buildSeason, buildShow } from './util'\nimport {\n  fetchEpisode,\n  fetchMovie,\n  fetchMovieCredits,\n  fetchSeason,\n  fetchSeasonCredits,\n  fetchShow,\n} from './api'\n\nexport const fetchEpisodeMetadata = async (\n  showId: string,\n  seasonId: string,\n  episode: EpisodeLike,\n): Promise<Episode> => {\n  const response = await fetchEpisode(\n    episode.showTmdbId,\n    episode.seasonNumber,\n    episode.number,\n  )\n\n  return buildEpisode(showId, seasonId, episode, response)\n}\n\nexport const fetchMovieMetadata = async (movie: MovieLike): Promise<Movie> => {\n  const response = await fetchMovie(movie.tmdbId)\n  const creditsResponse = await fetchMovieCredits(movie.tmdbId)\n\n  return buildMovie(movie, response, creditsResponse)\n}\n\nexport const fetchSeasonMetadata = async (\n  show: Show,\n  season: SeasonLike,\n): Promise<Season> => {\n  const response = await fetchSeason(season.showTmdbId, season.number)\n  const creditsResponse = await fetchSeasonCredits(\n    season.showTmdbId,\n    season.number,\n  )\n\n  return buildSeason(show, season, response, creditsResponse)\n}\n\nexport const fetchShowMetadata = async (show: ShowLike): Promise<Show> => {\n  const response = await fetchShow(show.tmdbId)\n\n  return buildShow(show, response)\n}\n","import { DriveItemChildrenResponse, DriveItemResponse } from './types'\nimport { Client } from '@microsoft/microsoft-graph-client'\n\nexport const getClient = (accessToken: string) =>\n  Client.init({\n    authProvider: (done) => done(null, accessToken),\n  })\n\nexport const fetchPathChildren = (\n  client: Client,\n  path: string,\n): Promise<DriveItemChildrenResponse> =>\n  client.api(`/me/drive/root:${path}:/children`).get()\n\nexport const fetchItem = (\n  client: Client,\n  itemId: string,\n): Promise<DriveItemResponse> => client.api(`/me/drive/items/${itemId}`).get()\n\nexport const fetchItemChildren = (\n  client: Client,\n  itemId: string,\n): Promise<DriveItemChildrenResponse> =>\n  client.api(`/me/drive/items/${itemId}/children`).get()\n","import { CaptionType, VTT_EXTENSION } from '../../types/files/captions/Caption'\nimport {\n  M4V_EXTENSION,\n  MKV_EXTENSION,\n  MP4_EXTENSION,\n  VideoType,\n  WEBM_EXTENSION,\n} from '../../types/files/videos/Video'\nimport { ProviderKind } from '../../types/providers/Provider'\n\nexport const parseFileName = (fileName: string) => ({\n  name: fileName.split('.').shift()!,\n  extension: fileName.split('.').pop(),\n})\n\nexport const parseCaptionType = (\n  extension: string,\n): CaptionType | undefined => {\n  switch (extension) {\n    case VTT_EXTENSION:\n      return VTT_EXTENSION\n  }\n}\n\nexport const parseVideoType = (extension: string): VideoType | undefined => {\n  switch (extension) {\n    case MP4_EXTENSION:\n      return MP4_EXTENSION\n    case M4V_EXTENSION:\n      return M4V_EXTENSION\n    case MKV_EXTENSION:\n      return MKV_EXTENSION\n    case WEBM_EXTENSION:\n      return WEBM_EXTENSION\n  }\n}\n\nexport const buildFileId = (kind: ProviderKind, id: string) => `${kind}@${id}`\n","import { Caption, CaptionType } from '../../../types/files/captions/Caption'\nimport { DriveItemResponse, FileResponse, VideoResponse } from './types'\nimport { File, FileKind } from '../../../types/files/File'\nimport { Video, VideoType } from '../../../types/files/videos/Video'\nimport {\n  buildFileId,\n  parseCaptionType,\n  parseFileName,\n  parseVideoType,\n} from '../util'\nimport { ProviderKind } from '../../../types/providers/Provider'\n\nconst buildCaption = (\n  providerId: string,\n  type: CaptionType,\n  name: string,\n  {\n    id,\n    name: fileName,\n    size,\n    webUrl,\n    '@microsoft.graph.downloadUrl': downloadUrl,\n  }: DriveItemResponse,\n  { mimeType }: FileResponse,\n): Caption => ({\n  kind: FileKind.Caption,\n  type,\n  id: buildFileId(ProviderKind.OneDrive, id),\n  name,\n  provider: {\n    kind: ProviderKind.OneDrive,\n    providerId,\n    id,\n    fileName,\n    size,\n    downloadUrl,\n    webUrl,\n    mimeType,\n  },\n})\n\nconst buildVideo = (\n  providerId: string,\n  type: VideoType,\n  name: string,\n  {\n    id,\n    name: fileName,\n    size,\n    webUrl,\n    '@microsoft.graph.downloadUrl': downloadUrl,\n  }: DriveItemResponse,\n  { mimeType }: FileResponse,\n  {\n    bitrate,\n    duration,\n    height,\n    width,\n    audioChannels,\n    audioFormat,\n    fourCC,\n    frameRate,\n  }: VideoResponse,\n): Video => ({\n  kind: FileKind.Video,\n  type,\n  id: buildFileId(ProviderKind.OneDrive, id),\n  name,\n  provider: {\n    kind: ProviderKind.OneDrive,\n    providerId,\n    id,\n    fileName,\n    size,\n    downloadUrl,\n    webUrl,\n    mimeType,\n    bitrate,\n    duration,\n    height,\n    width,\n    audioChannels,\n    audioFormat,\n    fourCC,\n    frameRate,\n  },\n})\n\nexport const buildFile = (providerId: string) => (\n  response: DriveItemResponse,\n): File | undefined => {\n  if (response.file === undefined) return\n\n  const { name, extension } = parseFileName(response.name)\n  if (extension === undefined) return\n\n  const captionType = parseCaptionType(extension)\n  const videoType = parseVideoType(extension)\n\n  if (captionType !== undefined)\n    return buildCaption(providerId, captionType, name, response, response.file)\n  else if (videoType !== undefined && response.video !== undefined)\n    return buildVideo(\n      providerId,\n      videoType,\n      name,\n      response,\n      response.file,\n      response.video,\n    )\n}\n","import { FileKind, IFile } from '../File'\nimport { CaptionProvider } from '../FileProvider'\n\nexport const VTT_EXTENSION = 'vtt'\n\nexport type CaptionType = typeof VTT_EXTENSION\n\nexport interface Caption extends IFile<CaptionProvider> {\n  kind: typeof FileKind.Caption\n  type: CaptionType\n}\n","import {\n  EpisodeIndexResponse,\n  IndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n  ShowIndexResponse,\n} from '../types'\nimport {\n  fetchItem,\n  fetchItemChildren,\n  fetchPathChildren,\n  getClient,\n} from './api'\nimport { CannotFindFileError } from '../../../errors/CannotFindFileError'\nimport { Client } from '@microsoft/microsoft-graph-client'\nimport { File } from '../../../types/files/File'\nimport { buildFile } from './util'\nimport { notUndefined } from '../../../util'\n\nexport const updateFile = async (\n  providerId: string,\n  accessToken: string,\n  file: File,\n): Promise<File> => {\n  const client = getClient(accessToken)\n  const response = await fetchItem(client, file.provider.id)\n  const newFile = buildFile(providerId)(response)\n\n  if (newFile !== undefined) return newFile\n  else throw new CannotFindFileError(file)\n}\n\nconst indexFiles = async (\n  providerId: string,\n  client: Client,\n  folderId: string,\n): Promise<File[]> => {\n  const { value: filesResponse } = await fetchItemChildren(client, folderId)\n\n  return filesResponse.map(buildFile(providerId)).filter(notUndefined)\n}\n\nconst indexMovies = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<MovieIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const { value: moviesResponse } = await fetchPathChildren(client, path)\n\n  return Promise.all(\n    moviesResponse.map(async (movieResponse) => ({\n      name: movieResponse.name,\n      files: await indexFiles(providerId, client, movieResponse.id),\n    })),\n  )\n}\n\nconst indexEpisodes = async (\n  providerId: string,\n  client: Client,\n  seasonFolderId: string,\n): Promise<EpisodeIndexResponse[]> => {\n  const { value: episodesResponse } = await fetchItemChildren(\n    client,\n    seasonFolderId,\n  )\n\n  const episodes = await Promise.all(\n    episodesResponse.map(async (episodeResponse) => {\n      const number = Number.parseInt(episodeResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        files: await indexFiles(providerId, client, episodeResponse.id),\n      }\n    }),\n  )\n\n  return episodes.filter(notUndefined)\n}\n\nconst indexSeasons = async (\n  providerId: string,\n  client: Client,\n  showFolderId: string,\n): Promise<SeasonIndexResponse[]> => {\n  const { value: seasonsResponse } = await fetchItemChildren(\n    client,\n    showFolderId,\n  )\n\n  const seasons = await Promise.all(\n    seasonsResponse.map(async (seasonResponse) => {\n      const number = Number.parseInt(seasonResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        episodes: await indexEpisodes(providerId, client, seasonResponse.id),\n      }\n    }),\n  )\n\n  return seasons.filter(notUndefined)\n}\n\nconst indexShows = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<ShowIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const { value: showsResponse } = await fetchPathChildren(client, path)\n\n  return Promise.all(\n    showsResponse.map(async (showResponse) => ({\n      name: showResponse.name,\n      seasons: await indexSeasons(providerId, client, showResponse.id),\n    })),\n  )\n}\n\nexport const index = async (\n  providerId: string,\n  accessToken: string,\n  moviesPath: string | undefined,\n  showsPath: string | undefined,\n): Promise<IndexResponse> => {\n  const client = getClient(accessToken)\n\n  return {\n    movies: await indexMovies(providerId, client, moviesPath),\n    shows: await indexShows(providerId, client, showsPath),\n  }\n}\n","import {\n  EpisodeIndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n} from './types'\nimport { File, FileKind } from '../../types/files/File'\nimport { Provider, ProviderKind } from '../../types/providers/Provider'\nimport { Caption } from '../../types/files/captions/Caption'\nimport { EpisodeLike } from '../../types/items/Episode'\nimport { ItemKind } from '../../types/items/Item'\nimport { MovieLike } from '../../types/items/Movie'\nimport { SeasonLike } from '../../types/items/Season'\nimport { ShowLike } from '../../types/items/Show'\nimport { Video } from '../../types/files/videos/Video'\nimport { updateFile as oneDriveUpdateFile } from './OneDrive'\n\nconst isCaption = (file: File): file is Caption =>\n  file.kind === FileKind.Caption\n\nconst isVideo = (file: File): file is Video => file.kind === FileKind.Video\n\nexport const buildEpisodeLike = (showTmdbId: number, seasonNumber: number) => (\n  item: EpisodeIndexResponse,\n): EpisodeLike => ({\n  kind: ItemKind.Episode,\n  number: item.number,\n  seasonNumber,\n  showTmdbId,\n  sources: item.files.filter(isVideo),\n  captions: item.files.filter(isCaption),\n  usage: {\n    lastWatched: undefined,\n    progress: undefined,\n  },\n})\n\nexport const buildMovieLike = (tmdbId: number) => (\n  item: MovieIndexResponse,\n): MovieLike => ({\n  kind: ItemKind.Movie,\n  tmdbId,\n  sources: item.files.filter(isVideo),\n  captions: item.files.filter(isCaption),\n  usage: {\n    lastWatched: undefined,\n    progress: undefined,\n  },\n})\n\nexport const buildSeasonLike = (showTmdbId: number) => (\n  item: SeasonIndexResponse,\n): SeasonLike => ({\n  kind: ItemKind.Season,\n  number: item.number,\n  showTmdbId,\n  usage: {\n    lastWatched: undefined,\n    progress: undefined,\n  },\n})\n\nexport const buildShowLike = (tmdbId: number) => (): ShowLike => ({\n  kind: ItemKind.Show,\n  tmdbId,\n  usage: {\n    lastWatched: undefined,\n    progress: undefined,\n  },\n})\n\nexport const updateFile = (provider: Provider, file: File): Promise<File> => {\n  switch (provider.kind) {\n    case ProviderKind.OneDrive:\n      return oneDriveUpdateFile(provider.id, provider.accessToken.token, file)\n  }\n}\n","import { Episode, EpisodeLike } from '../types/items/Episode'\nimport {\n  EpisodeIndexResponse,\n  IndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n  ShowIndexResponse,\n} from './drives/types'\nimport { Movie, MovieLike } from '../types/items/Movie'\nimport { Provider, ProviderKind } from '../types/providers/Provider'\nimport { Season, SeasonLike } from '../types/items/Season'\nimport { Show, ShowLike } from '../types/items/Show'\nimport {\n  buildEpisodeLike,\n  buildMovieLike,\n  buildSeasonLike,\n  buildShowLike,\n} from './drives'\nimport { findMovie, findShow } from './databases/TMDb/api'\nimport { index as oneDriveIndex } from '../services/drives/OneDrive'\n\nconst handleProvider = (provider: Provider): Promise<IndexResponse> => {\n  switch (provider.kind) {\n    case ProviderKind.OneDrive:\n      return oneDriveIndex(\n        provider.id,\n        provider.accessToken.token,\n        provider.moviesPath,\n        provider.showsPath,\n      )\n  }\n}\n\nconst indexMovies = (\n  moviesResponse: MovieIndexResponse[],\n  fetchMovieMetadata: (movie: MovieLike) => Promise<Movie>,\n) =>\n  Promise.all(\n    moviesResponse.map(async (movieResponse) => {\n      const tmdbId = await findMovie(movieResponse.name)\n      if (tmdbId === undefined) return\n\n      const movieAlike = buildMovieLike(tmdbId)(movieResponse)\n      await fetchMovieMetadata(movieAlike)\n    }),\n  )\n\nconst indexShows = (\n  showsResponse: ShowIndexResponse[],\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n  fetchShowMetadata: (show: ShowLike) => Promise<Show>,\n) =>\n  Promise.all(\n    showsResponse.map(async (showResponse) => {\n      const tmdbId = await findShow(showResponse.name)\n      if (tmdbId === undefined) return\n\n      const showAlike = buildShowLike(tmdbId)()\n      const show = await fetchShowMetadata(showAlike)\n      await indexSeasons(\n        showResponse.seasons,\n        show,\n        fetchEpisodeMetadata,\n        fetchSeasonMetadata,\n      )\n    }),\n  )\n\nconst indexSeasons = (\n  seasonsResponse: SeasonIndexResponse[],\n  show: Show,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n) =>\n  Promise.all(\n    seasonsResponse.map(async (seasonResponse) => {\n      const seasonAlike = buildSeasonLike(show.tmdbId)(seasonResponse)\n      const season = await fetchSeasonMetadata(show, seasonAlike)\n      await indexEpisodes(\n        seasonResponse.episodes,\n        show,\n        season,\n        fetchEpisodeMetadata,\n      )\n    }),\n  )\n\nconst indexEpisodes = (\n  episodesResponse: EpisodeIndexResponse[],\n  show: Show,\n  season: Season,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n) =>\n  Promise.all(\n    episodesResponse.map(async (episodeResponse) => {\n      const episodeAlike = buildEpisodeLike(\n        show.tmdbId,\n        season.number,\n      )(episodeResponse)\n      await fetchEpisodeMetadata(show.id, season.id, episodeAlike)\n    }),\n  )\n\nexport const index = async (\n  provider: Provider,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchMovieMetadata: (movie: MovieLike) => Promise<Movie>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n  fetchShowMetadata: (show: ShowLike) => Promise<Show>,\n) => {\n  const { movies: moviesResponse, shows: showsResponse } = await handleProvider(\n    provider,\n  )\n\n  await indexMovies(moviesResponse, fetchMovieMetadata)\n  await indexShows(\n    showsResponse,\n    fetchEpisodeMetadata,\n    fetchSeasonMetadata,\n    fetchShowMetadata,\n  )\n}\n","import { Episode, EpisodeLike } from '../types/items/Episode'\nimport { Movie, MovieLike } from '../types/items/Movie'\nimport { Season, SeasonLike } from '../types/items/Season'\nimport { Show, ShowLike } from '../types/items/Show'\nimport { episodeSelector, episodesSelector } from './episodes/selectors'\nimport {\n  fetchEpisodeMetadata as fetchEpisodeMetadataCall,\n  fetchMovieMetadata as fetchMovieMetadataCall,\n  fetchSeasonMetadata as fetchSeasonMetadataCall,\n  fetchShowMetadata as fetchShowMetadataCall,\n} from '../services/databases/TMDb'\nimport { movieSelector, moviesSelector } from './movies/selectors'\nimport { seasonSelector, seasonsSelector } from './seasons/selectors'\nimport { showSelector, showsSelector } from './shows/selectors'\nimport { AppThunk } from '.'\nimport { Caption } from '../types/files/captions/Caption'\nimport { File } from '../types/files/File'\nimport { ItemKind } from '../types/items/Item'\nimport { Provider } from '../types/providers/Provider'\nimport { Video } from '../types/files/videos/Video'\nimport { auth as authCall } from './auth/thunks'\nimport { removeFilesByProvider as episodeRemoveFilesByProvider } from './episodes/thunks'\nimport { index as indexCall } from '../services/indexing'\nimport { removeFilesByProvider as movieRemoveFilesByProvider } from './movies/thunks'\nimport { providerSelector } from './auth/selectors'\nimport { removeProvider as removeProviderAction } from './auth/actions'\nimport { updateEpisode } from './episodes/actions'\nimport { updateFile as updateFileCall } from '../services/drives'\nimport { updateMovie } from './movies/actions'\nimport { updateSeason } from './seasons/actions'\nimport { updateShow } from './shows/actions'\n\nexport const index = (providers: Provider[]): AppThunk<Promise<void>> => async (\n  dispatch,\n) => {\n  await Promise.all(\n    providers.map(async (provider) => {\n      const updatedProvider = await dispatch(authCall(provider))\n      if (updatedProvider === undefined)\n        throw new Error(\n          'cannot sign in using the redirect flow while updating files',\n        )\n\n      await indexCall(\n        updatedProvider,\n        (showId: string, seasonId: string, episode: EpisodeLike) =>\n          dispatch(fetchEpisodeMetadata(showId, seasonId, episode)),\n        (movie: MovieLike) => dispatch(fetchMovieMetadata(movie)),\n        (show: Show, season: SeasonLike) =>\n          dispatch(fetchSeasonMetadata(show, season)),\n        (show: ShowLike) => dispatch(fetchShowMetadata(show)),\n      )\n    }),\n  )\n}\n\nconst updateFile = (file: File): AppThunk<Promise<File>> => async (\n  dispatch,\n  getState,\n) => {\n  const { auth } = getState()\n  const provider = providerSelector(file.provider.providerId)(auth)\n  if (provider === undefined)\n    throw new Error('could not find provider for file')\n\n  const updatedProvider = await dispatch(authCall(provider))\n  if (updatedProvider === undefined)\n    throw new Error(\n      'cannot sign in using the redirect flow while updating files',\n    )\n\n  const updatedFile = await updateFileCall(updatedProvider, file)\n\n  return updatedFile\n}\n\nconst handleUpdateWatchableItem = (item: Episode | Movie) => {\n  switch (item.kind) {\n    case ItemKind.Episode:\n      return updateEpisode(item)\n    case ItemKind.Movie:\n      return updateMovie(item)\n  }\n}\n\nexport const updateFiles = (\n  item: Episode | Movie,\n): AppThunk<Promise<Episode | Movie>> => async (dispatch) => {\n  const sources = await Promise.all(\n    item.sources.map(\n      (source) => dispatch(updateFile(source)) as Promise<Video>,\n    ),\n  )\n  const captions = await Promise.all(\n    item.captions.map(\n      (caption) => dispatch(updateFile(caption)) as Promise<Caption>,\n    ),\n  )\n  const updatedItem = {\n    ...item,\n    sources,\n    captions,\n  }\n\n  handleUpdateWatchableItem(updatedItem)\n  return updatedItem\n}\n\nconst fetchEpisodeMetadata = (\n  showId: string,\n  seasonId: string,\n  episode: EpisodeLike,\n): AppThunk<Promise<Episode>> => async (dispatch, getState) => {\n  const { episodes } = getState()\n\n  const newEpisode = await fetchEpisodeMetadataCall(showId, seasonId, episode)\n  const oldEpisode = episodeSelector(newEpisode.id)(episodes)\n  if (oldEpisode !== undefined) newEpisode.usage = oldEpisode.usage\n\n  dispatch(updateEpisode(newEpisode))\n  return newEpisode\n}\n\nconst fetchMovieMetadata = (\n  movie: MovieLike,\n): AppThunk<Promise<Movie>> => async (dispatch, getState) => {\n  const { movies } = getState()\n\n  const newMovie = await fetchMovieMetadataCall(movie)\n  const oldMovie = movieSelector(newMovie.id)(movies)\n  if (oldMovie !== undefined) newMovie.usage = oldMovie.usage\n\n  dispatch(updateMovie(newMovie))\n  return newMovie\n}\n\nconst fetchSeasonMetadata = (\n  show: Show,\n  season: SeasonLike,\n): AppThunk<Promise<Season>> => async (dispatch, getState) => {\n  const { seasons } = getState()\n\n  const newSeason = await fetchSeasonMetadataCall(show, season)\n  const oldSeason = seasonSelector(newSeason.id)(seasons)\n  if (oldSeason !== undefined) newSeason.usage = oldSeason.usage\n\n  dispatch(updateSeason(newSeason))\n  return newSeason\n}\n\nconst fetchShowMetadata = (show: ShowLike): AppThunk<Promise<Show>> => async (\n  dispatch,\n  getState,\n) => {\n  const { shows } = getState()\n\n  const newShow = await fetchShowMetadataCall(show)\n  const oldShow = showSelector(newShow.id)(shows)\n  if (oldShow !== undefined) newShow.usage = oldShow.usage\n\n  dispatch(updateShow(newShow))\n  return newShow\n}\n\nconst fetchEpisodesMetadata = (): AppThunk<Promise<void>> => async (\n  dispatch,\n  getState,\n) => {\n  const { episodes } = getState()\n\n  await Promise.all(\n    episodesSelector(episodes).map(async (episode) =>\n      dispatch(fetchEpisodeMetadata(episode.showId, episode.seasonId, episode)),\n    ),\n  )\n}\n\nconst fetchMoviesMetadata = (): AppThunk<Promise<void>> => async (\n  dispatch,\n  getState,\n) => {\n  const { movies } = getState()\n\n  await Promise.all(\n    moviesSelector(movies).map(async (movie) =>\n      dispatch(fetchMovieMetadata(movie)),\n    ),\n  )\n}\n\nconst fetchSeasonsMetadata = (): AppThunk<Promise<void>> => async (\n  dispatch,\n  getState,\n) => {\n  const { seasons, shows } = getState()\n\n  await Promise.all(\n    seasonsSelector(seasons).map(async (season) => {\n      const show = showSelector(season.showId)(shows)\n      if (show === undefined) throw new Error('cannot find show for season')\n\n      return dispatch(fetchSeasonMetadata(show, season))\n    }),\n  )\n}\n\nconst fetchShowsMetadata = (): AppThunk<Promise<void>> => async (\n  dispatch,\n  getState,\n) => {\n  const { shows } = getState()\n\n  await Promise.all(\n    showsSelector(shows).map(async (show) => dispatch(fetchShowMetadata(show))),\n  )\n}\n\nexport const fetchAllMetadata = (): AppThunk<Promise<void>> => async (\n  dispatch,\n) => {\n  await dispatch(fetchMoviesMetadata())\n  await dispatch(fetchShowsMetadata())\n  await dispatch(fetchSeasonsMetadata())\n  await dispatch(fetchEpisodesMetadata())\n}\n\nexport const removeProvider = (id: string): AppThunk<void> => (\n  dispatch,\n  getState,\n) => {\n  dispatch(removeProviderAction(id))\n\n  const { episodes, movies } = getState()\n  episodesSelector(episodes).forEach((episode) =>\n    dispatch(episodeRemoveFilesByProvider(episode, id)),\n  )\n  moviesSelector(movies).forEach((movie) =>\n    dispatch(movieRemoveFilesByProvider(movie, id)),\n  )\n}\n","import {\n  AccountInfo,\n  InteractionRequiredAuthError,\n  PublicClientApplication,\n} from '@azure/msal-browser'\nimport { AuthenticationFailure } from '../../errors/AuthenticationFailure'\nimport { OneDrive } from '../../types/providers/OneDrive'\nimport { OneDriveAuthResponse } from './types'\nimport { ProviderKind } from '../../types/providers/Provider'\nimport { buildAuthId } from './util'\nimport { isMobile } from 'react-device-detect'\n\nconst CLIENT_ID = process.env.REACT_APP_MICROSOFT_CLIENT_ID!\nconst SCOPES = ['user.read', 'files.read.all']\n\nconst buildAuthResponse = (\n  accessToken: string,\n  account: AccountInfo,\n  expiresOn: Date,\n): OneDriveAuthResponse => ({\n  kind: ProviderKind.OneDrive,\n  accessToken: { token: accessToken, validUntil: expiresOn.toISOString() },\n  id: buildAuthId(ProviderKind.OneDrive, account.username),\n  name: account.username,\n  account,\n})\n\nconst silentLogIn = async (\n  app: PublicClientApplication,\n  account: AccountInfo,\n): Promise<OneDriveAuthResponse> => {\n  const {\n    accessToken,\n    account: newAccount,\n    expiresOn,\n  } = await app.acquireTokenSilent({\n    scopes: SCOPES,\n    account,\n  })\n  if (!newAccount || !expiresOn)\n    throw new AuthenticationFailure(ProviderKind.OneDrive)\n  return buildAuthResponse(accessToken, newAccount, expiresOn)\n}\n\nconst popupLogIn = async (\n  app: PublicClientApplication,\n): Promise<OneDriveAuthResponse> => {\n  const { account } = await app.loginPopup({\n    scopes: SCOPES,\n  })\n  if (!account) throw new AuthenticationFailure(ProviderKind.OneDrive)\n  return silentLogIn(app, account)\n}\n\nconst redirectLogIn = (app: PublicClientApplication) =>\n  app.loginRedirect({\n    scopes: SCOPES,\n  })\n\nconst interactiveLogIn = async (\n  app: PublicClientApplication,\n  onRedirect: () => void,\n) => {\n  if (isMobile) {\n    onRedirect()\n    return redirectLogIn(app)\n  }\n  return await popupLogIn(app)\n}\n\nconst performAuth = async (\n  app: PublicClientApplication,\n  account: AccountInfo | undefined,\n  onRedirect: () => void,\n): Promise<OneDriveAuthResponse | void> => {\n  if (account === undefined) return await interactiveLogIn(app, onRedirect)\n\n  try {\n    return await silentLogIn(app, account)\n  } catch (error: unknown) {\n    if (error instanceof InteractionRequiredAuthError)\n      return await interactiveLogIn(app, onRedirect)\n    else throw error\n  }\n}\n\nexport const auth = async (\n  provider: OneDrive | undefined,\n  onRedirect: () => void,\n): Promise<OneDriveAuthResponse | void> => {\n  if (\n    provider !== undefined &&\n    new Date(provider.accessToken.validUntil) > new Date()\n  )\n    return provider\n\n  const app = new PublicClientApplication({\n    auth: {\n      clientId: CLIENT_ID,\n    },\n  })\n\n  try {\n    return await performAuth(app, provider?.account, onRedirect)\n  } catch (error: unknown) {\n    throw new AuthenticationFailure(ProviderKind.OneDrive)\n  }\n}\n\nexport const authHandleRedirect = async (): Promise<OneDriveAuthResponse> => {\n  const app = new PublicClientApplication({\n    auth: {\n      clientId: CLIENT_ID,\n    },\n  })\n  console.log(window.location.hash) // eslint-disable-line no-console\n  const response = await app.handleRedirectPromise()\n  console.log(response) // eslint-disable-line no-console\n  if (!response?.account) throw new AuthenticationFailure(ProviderKind.OneDrive)\n  return silentLogIn(app, response.account)\n}\n","import { ProviderKind } from '../../types/providers/Provider'\n\nexport const buildAuthId = (kind: ProviderKind, id: string) => `${kind}@${id}`\n","import { LoginRedirectCache, SetupRedirectCache } from './types'\nimport {\n  Provider,\n  ProviderKind,\n  ProviderKindWithRedirect,\n} from '../../types/providers/Provider'\nimport {\n  expectLoginRedirect,\n  expectSetupRedirect,\n  updateProvider,\n} from './actions'\nimport {\n  auth as oneDriveAuthCall,\n  authHandleRedirect as oneDriveAuthHandleRedirectCall,\n} from '../../services/auth/OneDrive'\nimport { AppThunk } from '../index'\nimport { AuthResponse } from '../../services/auth/types'\nimport { ProviderAlreadyExists } from '../../errors/ProviderAlreadyExists'\nimport { providersSelector } from './selectors'\n\nconst authHandleProvider = (\n  provider: Provider,\n  onRedirect: () => void,\n): Promise<AuthResponse | void> => {\n  switch (provider.kind) {\n    case ProviderKind.OneDrive:\n      return oneDriveAuthCall(provider, onRedirect)\n  }\n}\n\nconst setupAuthHandleProvider = (\n  kind: ProviderKind,\n  onRedirect: () => void,\n): Promise<AuthResponse | void> => {\n  switch (kind) {\n    case ProviderKind.OneDrive:\n      return oneDriveAuthCall(undefined, onRedirect)\n  }\n}\n\nconst authHandleRedirectHandleProvider = (\n  kind: ProviderKindWithRedirect,\n): Promise<AuthResponse> => {\n  switch (kind) {\n    case ProviderKind.OneDrive:\n      return oneDriveAuthHandleRedirectCall()\n  }\n}\n\nconst authHandleResponse = (\n  provider: Provider,\n  response: AuthResponse,\n): AppThunk<Promise<Provider>> => async (dispatch) => {\n  const updatedProvider = {\n    ...response,\n    moviesPath: provider.moviesPath,\n    showsPath: provider.showsPath,\n  }\n  dispatch(updateProvider(updatedProvider))\n  return updatedProvider\n}\n\nexport const auth = (\n  provider: Provider,\n): AppThunk<Promise<Provider | undefined>> => async (dispatch) => {\n  const response = await authHandleProvider(provider, () =>\n    dispatch(expectLoginRedirect(provider)),\n  )\n  if (response === undefined) return\n  return dispatch(authHandleResponse(provider, response))\n}\n\nconst setupAuthHandleResponse = (\n  kind: ProviderKind,\n  response: AuthResponse,\n): AppThunk<Promise<AuthResponse>> => async (_, getState) => {\n  const { auth } = getState()\n  const provider = providersSelector(auth).find(\n    (provider) => provider.kind === kind && provider.name === response.name,\n  )\n  if (provider !== undefined) throw new ProviderAlreadyExists(provider)\n  return response\n}\n\nexport const setupAuth = (\n  kind: ProviderKind,\n): AppThunk<Promise<AuthResponse | undefined>> => async (dispatch) => {\n  const response = await setupAuthHandleProvider(kind, () =>\n    dispatch(expectSetupRedirect(kind)),\n  )\n  if (response === undefined) return\n  return dispatch(setupAuthHandleResponse(kind, response))\n}\n\nexport const authHandleRedirect = (\n  cache: LoginRedirectCache,\n): AppThunk<Promise<Provider>> => async (dispatch) => {\n  const response = await authHandleRedirectHandleProvider(cache.provider.kind)\n  return dispatch(authHandleResponse(cache.provider, response))\n}\n\nexport const setupAuthHandleRedirect = (\n  cache: SetupRedirectCache,\n): AppThunk<Promise<AuthResponse>> => async (dispatch) => {\n  const response = await authHandleRedirectHandleProvider(cache.kind)\n  return dispatch(setupAuthHandleResponse(cache.kind, response))\n}\n","export class APIError extends Error {\n  status: number\n\n  constructor(status: number, message: string) {\n    super(message)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, APIError)\n    }\n\n    this.name = 'APIError'\n    this.status = status\n  }\n}\n","import { ProviderKind } from '../types/providers/Provider'\n\nexport class AuthenticationFailure extends Error {\n  provider: ProviderKind\n\n  constructor(provider: ProviderKind) {\n    super()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationFailure)\n    }\n\n    this.name = 'AuthenticationFailure'\n    this.provider = provider\n  }\n}\n","import { Provider } from '../types/providers/Provider'\n\nexport class ProviderAlreadyExists extends Error {\n  provider: Provider\n\n  constructor(provider: Provider) {\n    super()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProviderAlreadyExists)\n    }\n\n    this.name = 'ProviderAlreadyExists'\n    this.provider = provider\n  }\n}\n","import { EpisodesActionTypes, REMOVE_EPISODE, UPDATE_EPISODE } from './types'\nimport { Episode } from '../../types/items/Episode'\n\nexport const updateEpisode = (episode: Episode): EpisodesActionTypes => ({\n  type: UPDATE_EPISODE,\n  payload: { episode },\n})\n\nexport const removeEpisode = (id: string): EpisodesActionTypes => ({\n  type: REMOVE_EPISODE,\n  payload: { id },\n})\n","import { REMOVE_SEASON, SeasonsActionTypes, UPDATE_SEASON } from './types'\nimport { Season } from '../../types/items/Season'\n\nexport const updateSeason = (season: Season): SeasonsActionTypes => ({\n  type: UPDATE_SEASON,\n  payload: { season },\n})\n\nexport const removeSeason = (id: string): SeasonsActionTypes => ({\n  type: REMOVE_SEASON,\n  payload: { id },\n})\n","import { REMOVE_SHOW, ShowsActionTypes, UPDATE_SHOW } from './types'\nimport { Show } from '../../types/items/Show'\n\nexport const updateShow = (show: Show): ShowsActionTypes => ({\n  type: UPDATE_SHOW,\n  payload: { show },\n})\n\nexport const removeShow = (id: string): ShowsActionTypes => ({\n  type: REMOVE_SHOW,\n  payload: { id },\n})\n","import { File } from '../types/files/File'\n\nexport class CannotFindFileError extends Error {\n  file: File\n\n  constructor(file: File) {\n    super()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CannotFindFileError)\n    }\n\n    this.name = 'CannotFindFileError'\n    this.file = file\n  }\n}\n","import { AppThunk } from '../index'\nimport { Movie } from '../../types/items/Movie'\nimport { Usage } from '../../types/items/Item'\nimport { updateMovie } from './actions'\n\nexport const updateMovieProgress = (\n  movie: Movie,\n  progress: number,\n): AppThunk<void> => (dispatch) => {\n  const usage: Usage = {\n    lastWatched: new Date().toISOString(),\n    progress,\n  }\n  dispatch(updateMovie({ ...movie, usage }))\n}\n\nexport const removeFilesByProvider = (\n  movie: Movie,\n  providerId: string,\n): AppThunk<void> => (dispatch) => {\n  dispatch(\n    updateMovie({\n      ...movie,\n      sources: movie.sources.filter(\n        (source) => source.provider.providerId !== providerId,\n      ),\n      captions: movie.captions.filter(\n        (caption) => caption.provider.providerId !== providerId,\n      ),\n    }),\n  )\n}\n","import { MoviesActionTypes, REMOVE_MOVIE, UPDATE_MOVIE } from './types'\nimport { Movie } from '../../types/items/Movie'\n\nexport const updateMovie = (movie: Movie): MoviesActionTypes => ({\n  type: UPDATE_MOVIE,\n  payload: { movie },\n})\n\nexport const removeMovie = (id: string): MoviesActionTypes => ({\n  type: REMOVE_MOVIE,\n  payload: { id },\n})\n","import { AppThunk } from '../index'\nimport { Season } from '../../types/items/Season'\nimport { Usage } from '../../types/items/Item'\nimport { showSelector } from '../shows/selectors'\nimport { updateSeason } from './actions'\nimport { updateShowProgress } from '../shows/thunks'\n\nexport const updateSeasonProgress = (\n  season: Season,\n  progress: number,\n): AppThunk<void> => (dispatch, getState) => {\n  const usage: Usage = {\n    lastWatched: new Date().toISOString(),\n    progress,\n  }\n  dispatch(updateSeason({ ...season, usage }))\n\n  const { shows } = getState()\n  const show = showSelector(season.showId)(shows)\n  if (show === undefined) throw new Error('parent show of season undefined')\n\n  dispatch(updateShowProgress(show, season.number))\n}\n","import { AppThunk } from '../index'\nimport { Show } from '../../types/items/Show'\nimport { Usage } from '../../types/items/Item'\nimport { updateShow } from './actions'\n\nexport const updateShowProgress = (\n  show: Show,\n  progress: number,\n): AppThunk<void> => (dispatch) => {\n  const usage: Usage = {\n    lastWatched: new Date().toISOString(),\n    progress,\n  }\n  dispatch(updateShow({ ...show, usage }))\n}\n","import { AppThunk } from '../index'\nimport { Episode } from '../../types/items/Episode'\nimport { Usage } from '../../types/items/Item'\nimport { seasonSelector } from '../seasons/selectors'\nimport { updateEpisode } from './actions'\nimport { updateSeasonProgress } from '../seasons/thunks'\n\nexport const updateEpisodeProgress = (\n  episode: Episode,\n  progress: number,\n): AppThunk<void> => (dispatch, getState) => {\n  const usage: Usage = {\n    lastWatched: new Date().toISOString(),\n    progress,\n  }\n  dispatch(updateEpisode({ ...episode, usage }))\n\n  const { seasons } = getState()\n  const season = seasonSelector(episode.seasonId)(seasons)\n  if (season === undefined)\n    throw new Error('parent season of episode undefined')\n\n  dispatch(updateSeasonProgress(season, episode.number))\n}\n\nexport const removeFilesByProvider = (\n  episode: Episode,\n  providerId: string,\n): AppThunk<void> => (dispatch) => {\n  dispatch(\n    updateEpisode({\n      ...episode,\n      sources: episode.sources.filter(\n        (source) => source.provider.providerId !== providerId,\n      ),\n      captions: episode.captions.filter(\n        (caption) => caption.provider.providerId !== providerId,\n      ),\n    }),\n  )\n}\n"],"sourceRoot":""}