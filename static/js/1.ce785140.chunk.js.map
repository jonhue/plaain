{"version":3,"sources":["store/movies/selectors.ts","store/shows/selectors.ts","store/seasons/selectors.ts","store/episodes/selectors.ts","components/Modal.tsx","hooks/modal.ts","services/http.ts","types/files/File.ts","services/databases/TMDb/api.ts","services/databases/TMDb/index.ts","services/drives/util.ts","types/files/Caption.ts","services/drives/FTP/util.ts","services/drives/FTP/index.ts","services/drives/OneDrive/api.ts","services/drives/OneDrive/util.ts","services/drives/OneDrive/index.ts","services/drives/index.tsx","services/indexing.ts","store/thunks.ts","store/episodes/actions.ts","store/seasons/actions.ts","store/shows/actions.ts","store/movies/thunks.ts","store/movies/actions.ts","store/seasons/thunks.ts","store/shows/thunks.ts","store/episodes/thunks.ts"],"names":["movieSelector","id","state","moviesSelector","Object","keys","map","inProgressSelector","filter","isInProgress","recentlyWatchedSelector","movie","wasRecentlyWatched","RECENTLY_WATCHED_THRESHOLD","moviesByPersonSelector","createSelector","movies","cast","find","person","crew","moviesPersonSelector","fn","reduce","acc","people","concat","showSelector","showsSelector","seasonSelector","seasonsSelector","season","seasonsByShowSelector","showId","seasons","seasonsByPersonSelector","seasonsPersonSelector","episodeSelector","episodesSelector","episodesBySeasonSelector","seasonId","episodes","episode","Modal","isActive","onClose","children","modalRef","useRef","useOnClickOutside","className","classNames","active","ref","useModal","useState","show","setShow","useCallback","HttpMethod","FileKind","buildUrl","baseUrl","path","params","url","URL","undefined","entries","key","value","searchParams","append","http","method","accessToken","a","fetch","href","headers","Authorization","Accept","response","text","body","JSON","parse","ok","APIError","status","statusText","get","GET","BASE_URL","ACCESS_TOKEN","process","findMovie","query","language","i18next","results","length","findShow","fetchMovieCredits","fetchSeasonCredits","seasonNumber","fetchEpisode","episodeNumber","fetchEpisodeMetadata","showTmdbId","number","buildEpisode","fetchMovieMetadata","tmdbId","creditsResponse","buildMovie","fetchSeasonMetadata","buildSeason","fetchShowMetadata","buildShow","parseFileName","fileName","name","split","shift","extension","pop","parseCaptionType","parseVideoType","MP4_EXTENSION","M4V_EXTENSION","MKV_EXTENSION","WEBM_EXTENSION","buildFileId","kind","buildFile","providerId","captionType","videoType","type","size","uniqueID","Caption","ProviderKind","FTP","provider","buildCaption","Video","buildVideo","updateFile","file","getClient","host","port","username","password","secure","client","fetchItem","CannotFindFileError","Error","newFile","indexFiles","fetchItems","filesResponse","notUndefined","indexMovies","moviesResponse","Promise","all","movieResponse","files","indexEpisodes","seasonFolderPath","episodesResponse","episodeResponse","Number","parseInt","isNaN","indexSeasons","showFolderPath","seasonsResponse","seasonResponse","indexShows","showsResponse","showResponse","index","moviesPath","showsPath","shows","Client","init","authProvider","done","fetchPathChildren","api","itemId","fetchItemChildren","webUrl","downloadUrl","mimeType","OneDrive","video","bitrate","duration","height","width","audioChannels","audioFormat","fourCC","frameRate","token","folderId","seasonFolderId","showFolderId","isCaption","isVideo","buildEpisodeLike","item","ItemKind","Episode","sources","captions","usage","lastWatched","progress","buildMovieLike","Movie","buildSeasonLike","Season","buildShowLike","Show","ftpUpdateFile","oneDriveUpdateFile","handleProvider","ftpIndex","oneDriveIndex","movieAlike","showAlike","seasonAlike","episodeAlike","providers","dispatch","authCall","updatedProvider","indexCall","getState","auth","providerSelector","updateFileCall","updatedFile","handleUpdateWatchableItem","updateEpisode","updateMovie","updateFiles","source","caption","updatedItem","fetchEpisodeMetadataCall","newEpisode","oldEpisode","fetchMovieMetadataCall","newMovie","oldMovie","fetchSeasonMetadataCall","newSeason","oldSeason","updateSeason","fetchShowMetadataCall","newShow","oldShow","updateShow","fetchAllMetadata","UPDATE_EPISODE","payload","UPDATE_SEASON","UPDATE_SHOW","updateMovieProgress","Date","toISOString","removeFilesByProvider","UPDATE_MOVIE","updateSeasonProgress","updateShowProgress","updateEpisodeProgress"],"mappings":"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","file":"static/js/1.ce785140.chunk.js","sourcesContent":["import { isInProgress, wasRecentlyWatched } from '../../util'\nimport { Movie } from '../../types/items/Movie'\nimport { MoviesState } from './types'\nimport { Person } from '../../types/items/Person'\nimport { RECENTLY_WATCHED_THRESHOLD } from '../../constants'\nimport { createSelector } from 'reselect'\n\nexport const movieSelector = (id: string) => (state: MoviesState) => state[id]\n\nexport const moviesSelector = (state: MoviesState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const inProgressSelector = (state: MoviesState) =>\n  moviesSelector(state).filter(isInProgress)\n\nexport const recentlyWatchedSelector = (state: MoviesState) =>\n  moviesSelector(state).filter((movie) =>\n    wasRecentlyWatched(movie, RECENTLY_WATCHED_THRESHOLD),\n  )\n\nexport const moviesByPersonSelector = (id: string) =>\n  createSelector(moviesSelector, (movies) =>\n    movies.filter(\n      (movie) =>\n        movie.cast.find((person) => person.id === id) ||\n        movie.crew.find((person) => person.id === id),\n    ),\n  )\n\nexport const moviesPersonSelector = (\n  id: string,\n  fn: (movie: Movie) => Person[],\n) =>\n  createSelector(moviesSelector, (movies) =>\n    movies\n      .map(fn)\n      .reduce((acc, people) => acc.concat(people), [])\n      .filter((person) => person.id === id),\n  )\n","import { ShowsState } from './types'\n\nexport const showSelector = (id: string) => (state: ShowsState) => state[id]\n\nexport const showsSelector = (state: ShowsState) =>\n  Object.keys(state).map((id) => state[id]!)\n","import { isInProgress, wasRecentlyWatched } from '../../util'\nimport { Person } from '../../types/items/Person'\nimport { RECENTLY_WATCHED_THRESHOLD } from '../../constants'\nimport { Season } from '../../types/items/Season'\nimport { SeasonsState } from './types'\nimport { createSelector } from 'reselect'\n\nexport const seasonSelector = (id: string) => (state: SeasonsState) => state[id]\n\nexport const seasonsSelector = (state: SeasonsState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const inProgressSelector = (state: SeasonsState) =>\n  seasonsSelector(state).filter(isInProgress)\n\nexport const recentlyWatchedSelector = (state: SeasonsState) =>\n  seasonsSelector(state).filter((season) =>\n    wasRecentlyWatched(season, RECENTLY_WATCHED_THRESHOLD),\n  )\n\nexport const seasonsByShowSelector = (showId: string) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons.filter((season) => season.showId === showId),\n  )\n\nexport const seasonsByPersonSelector = (id: string) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons.filter(\n      (season) =>\n        season.cast.find((person) => person.id === id) ||\n        season.crew.find((person) => person.id === id),\n    ),\n  )\n\nexport const seasonsPersonSelector = (\n  id: string,\n  fn: (season: Season) => Person[],\n) =>\n  createSelector(seasonsSelector, (seasons) =>\n    seasons\n      .map(fn)\n      .reduce((acc, people) => acc.concat(people), [])\n      .filter((person) => person.id === id),\n  )\n","import { EpisodesState } from './types'\nimport { createSelector } from 'reselect'\n\nexport const episodeSelector = (id: string) => (state: EpisodesState) =>\n  state[id]\n\nexport const episodesSelector = (state: EpisodesState) =>\n  Object.keys(state).map((id) => state[id]!)\n\nexport const episodesBySeasonSelector = (seasonId: string) =>\n  createSelector(episodesSelector, (episodes) =>\n    episodes.filter((episode) => episode.seasonId === seasonId),\n  )\n","import './Modal.scss'\nimport React, { FunctionComponent, useRef } from 'react'\nimport classNames from 'classnames'\nimport useOnClickOutside from 'use-onclickoutside'\n\ntype ModalProps = {\n  isActive: boolean\n\n  onClose: () => void\n}\n\nexport const Modal: FunctionComponent<ModalProps> = ({\n  isActive,\n  onClose,\n  children,\n}) => {\n  const modalRef = useRef(null)\n  useOnClickOutside(modalRef, onClose)\n\n  return (\n    <div className={classNames('Modal', { active: isActive })}>\n      <div className=\"Modal__wrapper\" ref={modalRef}>\n        {children}\n      </div>\n    </div>\n  )\n}\n","import { useCallback, useState } from 'react'\n\nexport const useModal = (): [\n  show: boolean,\n  handleOpen: () => void,\n  handleClose: () => void,\n] => {\n  const [show, setShow] = useState(false)\n  const handleOpen = useCallback(() => setShow(true), [setShow])\n  const handleClose = useCallback(() => setShow(false), [setShow])\n\n  return [show, handleOpen, handleClose]\n}\n","import { APIError } from '../errors/APIError'\n\nenum HttpMethod {\n  GET = 'GET',\n}\n\ntype Params = Record<string, string>\n\nconst buildUrl = (baseUrl: string, path: string, params?: Params) => {\n  const url = new URL(`${baseUrl}/${path}`)\n\n  if (params !== undefined)\n    for (const [key, value] of Object.entries(params))\n      url.searchParams.append(key, value)\n\n  return url\n}\n\nconst http = async <T>(\n  baseUrl: string,\n  path: string,\n  method: HttpMethod,\n  accessToken: string,\n  params?: Params,\n): Promise<T> => {\n  const response = await fetch(buildUrl(baseUrl, path, params).href, {\n    method,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n  })\n\n  // check if response is empty\n  // if empty just return an empty object\n  const text = await response.text()\n  const body = text ? JSON.parse(text) : {}\n\n  if (response.ok) return body\n  else throw new APIError(response.status, response.statusText)\n}\n\nexport const get = <T>(\n  baseUrl: string,\n  path: string,\n  accessToken: string,\n  params: Params,\n) => http<T>(baseUrl, path, HttpMethod.GET, accessToken, params)\n","import { Caption } from './Caption'\nimport { FileProvider } from './FileProvider'\nimport { Video } from './Video'\n\nexport enum FileKind {\n  Video,\n  Caption,\n}\n\nexport interface IFile<T extends FileProvider> {\n  kind: FileKind\n  id: string\n  name: string\n  provider: T\n}\n\nexport type File = Caption | Video\n","import {\n  MovieCreditsResponse,\n  MovieDetailsResponse,\n  SearchMoviesResponse,\n  SearchTVShowsResponse,\n  TVEpisodeResponse,\n  TVSeasonCreditsResponse,\n  TVSeasonDetailsResponse,\n  TVShowDetailsResponse,\n} from './types'\nimport { get } from '../../http'\nimport i18next from 'i18next'\n\nconst BASE_URL = 'https://api.themoviedb.org/3'\nconst ACCESS_TOKEN = process.env.REACT_APP_TMDB_API_READ_ACCESS_TOKEN!\n\nexport const findMovie = async (query: string) => {\n  const { results } = await get<SearchMoviesResponse>(\n    BASE_URL,\n    'search/movie',\n    ACCESS_TOKEN,\n    { language: i18next.language, query },\n  )\n\n  if (results.length === 0) return undefined\n  else return results[0].id\n}\n\nexport const findShow = async (query: string) => {\n  const { results } = await get<SearchTVShowsResponse>(\n    BASE_URL,\n    'search/tv',\n    ACCESS_TOKEN,\n    { language: i18next.language, query },\n  )\n\n  if (results.length === 0) return undefined\n  else return results[0].id\n}\n\nexport const fetchMovie = (id: number) =>\n  get<MovieDetailsResponse>(BASE_URL, `movie/${id}`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchMovieCredits = (id: number) =>\n  get<MovieCreditsResponse>(BASE_URL, `movie/${id}/credits`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchShow = (id: number) =>\n  get<TVShowDetailsResponse>(BASE_URL, `tv/${id}`, ACCESS_TOKEN, {\n    language: i18next.language,\n  })\n\nexport const fetchSeason = (showId: number, seasonNumber: number) =>\n  get<TVSeasonDetailsResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n\nexport const fetchSeasonCredits = (showId: number, seasonNumber: number) =>\n  get<TVSeasonCreditsResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}/credits`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n\nexport const fetchEpisode = (\n  showId: number,\n  seasonNumber: number,\n  episodeNumber: number,\n) =>\n  get<TVEpisodeResponse>(\n    BASE_URL,\n    `tv/${showId}/season/${seasonNumber}/episode/${episodeNumber}`,\n    ACCESS_TOKEN,\n    { language: i18next.language },\n  )\n","import { Episode, EpisodeLike } from '../../../types/items/Episode'\nimport { Movie, MovieLike } from '../../../types/items/Movie'\nimport { Season, SeasonLike } from '../../../types/items/Season'\nimport { Show, ShowLike } from '../../../types/items/Show'\nimport { buildEpisode, buildMovie, buildSeason, buildShow } from './util'\nimport {\n  fetchEpisode,\n  fetchMovie,\n  fetchMovieCredits,\n  fetchSeason,\n  fetchSeasonCredits,\n  fetchShow,\n} from './api'\n\nexport const fetchEpisodeMetadata = async (\n  showId: string,\n  seasonId: string,\n  episode: EpisodeLike,\n): Promise<Episode> => {\n  const response = await fetchEpisode(\n    episode.showTmdbId,\n    episode.seasonNumber,\n    episode.number,\n  )\n\n  return buildEpisode(showId, seasonId, episode, response)\n}\n\nexport const fetchMovieMetadata = async (movie: MovieLike): Promise<Movie> => {\n  const response = await fetchMovie(movie.tmdbId)\n  const creditsResponse = await fetchMovieCredits(movie.tmdbId)\n\n  return buildMovie(movie, response, creditsResponse)\n}\n\nexport const fetchSeasonMetadata = async (\n  show: Show,\n  season: SeasonLike,\n): Promise<Season> => {\n  const response = await fetchSeason(season.showTmdbId, season.number)\n  const creditsResponse = await fetchSeasonCredits(\n    season.showTmdbId,\n    season.number,\n  )\n\n  return buildSeason(show, season, response, creditsResponse)\n}\n\nexport const fetchShowMetadata = async (show: ShowLike): Promise<Show> => {\n  const response = await fetchShow(show.tmdbId)\n\n  return buildShow(show, response)\n}\n","import { CaptionType, VTT_EXTENSION } from '../../types/files/Caption'\nimport {\n  M4V_EXTENSION,\n  MKV_EXTENSION,\n  MP4_EXTENSION,\n  VideoType,\n  WEBM_EXTENSION,\n} from '../../types/files/Video'\nimport { ProviderKind } from '../../types/providers/Provider'\n\nexport const parseFileName = (fileName: string) => ({\n  name: fileName.split('.').shift()!,\n  extension: fileName.split('.').pop(),\n})\n\nexport const parseCaptionType = (\n  extension: string,\n): CaptionType | undefined => {\n  switch (extension) {\n    case VTT_EXTENSION:\n      return VTT_EXTENSION\n  }\n}\n\nexport const parseVideoType = (extension: string): VideoType | undefined => {\n  switch (extension) {\n    case MP4_EXTENSION:\n      return MP4_EXTENSION\n    case M4V_EXTENSION:\n      return M4V_EXTENSION\n    case MKV_EXTENSION:\n      return MKV_EXTENSION\n    case WEBM_EXTENSION:\n      return WEBM_EXTENSION\n  }\n}\n\nexport const buildFileId = (kind: ProviderKind, id: string) => `${kind}@${id}`\n","import {\n  CaptionProvider,\n  IFTPFileProvider,\n  IOneDriveFileProvider,\n} from './FileProvider'\nimport { FileKind, IFile } from './File'\n\nexport const VTT_EXTENSION = 'vtt'\n\nexport type CaptionType = typeof VTT_EXTENSION\n\nexport interface Caption extends IFile<CaptionProvider> {\n  kind: typeof FileKind.Caption\n  type: CaptionType\n}\n\nexport type FTPCaption = IFTPFileProvider\n\nexport type OneDriveCaption = IOneDriveFileProvider\n","import { Caption, CaptionType } from '../../../types/files/Caption'\nimport { File, FileKind } from '../../../types/files/File'\nimport { Video, VideoType } from '../../../types/files/Video'\nimport {\n  buildFileId,\n  parseCaptionType,\n  parseFileName,\n  parseVideoType,\n} from '../util'\nimport { FileInfo } from 'basic-ftp'\nimport { ProviderKind } from '../../../types/providers/Provider'\n\nconst buildCaption = (\n  providerId: string,\n  path: string,\n  type: CaptionType,\n  name: string,\n  { name: fileName, size, uniqueID }: FileInfo,\n): Caption => ({\n  kind: FileKind.Caption,\n  type,\n  id: buildFileId(ProviderKind.FTP, uniqueID || fileName),\n  name,\n  provider: {\n    kind: ProviderKind.FTP,\n    providerId,\n    fileName,\n    path,\n    size,\n  },\n})\n\nconst buildVideo = (\n  providerId: string,\n  path: string,\n  type: VideoType,\n  name: string,\n  { name: fileName, size, uniqueID }: FileInfo,\n): Video => ({\n  kind: FileKind.Video,\n  type,\n  id: buildFileId(ProviderKind.FTP, uniqueID || fileName),\n  name,\n  provider: {\n    kind: ProviderKind.FTP,\n    providerId,\n    fileName,\n    path,\n    size,\n  },\n})\n\nexport const buildFile =\n  (providerId: string, path: string) =>\n  (response: FileInfo): File | undefined => {\n    const { name, extension } = parseFileName(response.name)\n    if (extension === undefined) return\n\n    const captionType = parseCaptionType(extension)\n    const videoType = parseVideoType(extension)\n\n    if (captionType !== undefined)\n      return buildCaption(providerId, path, captionType, name, response)\n    else if (videoType !== undefined)\n      return buildVideo(providerId, path, videoType, name, response)\n  }\n","import {\n  EpisodeIndexResponse,\n  IndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n  ShowIndexResponse,\n} from '../types'\nimport { fetchItem, fetchItems, getClient } from './api'\nimport { CannotFindFileError } from '../../../errors/CannotFindFileError'\nimport { Client } from 'basic-ftp'\nimport { FTP } from '../../../types/providers/FTP'\nimport { File } from '../../../types/files/File'\nimport { ProviderKind } from '../../../types/providers/Provider'\nimport { buildFile } from './util'\nimport { notUndefined } from '../../../util'\n\nexport const updateFile = async (provider: FTP, file: File): Promise<File> => {\n  const client = await getClient(\n    provider.host,\n    provider.port,\n    provider.username,\n    provider.password,\n    provider.secure,\n  )\n  const response = await fetchItem(client, file.provider.fileName)\n  if (response === undefined) throw new CannotFindFileError(file)\n  if (file.provider.kind !== ProviderKind.FTP)\n    throw new Error(\n      'Internal error: attempted to update file with the wrong provider.',\n    )\n  const newFile = buildFile(provider.id, file.provider.path)(response)\n\n  if (newFile !== undefined) return newFile\n  else throw new CannotFindFileError(file)\n}\n\nconst indexFiles = async (\n  providerId: string,\n  client: Client,\n  path: string,\n): Promise<File[]> => {\n  const filesResponse = await fetchItems(client, path)\n  return filesResponse.map(buildFile(providerId, path)).filter(notUndefined)\n}\n\nconst indexMovies = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<MovieIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const moviesResponse = await fetchItems(client, path)\n\n  return Promise.all(\n    moviesResponse.map(async (movieResponse) => ({\n      name: movieResponse.name,\n      files: await indexFiles(\n        providerId,\n        client,\n        `${path}/${movieResponse.name}`,\n      ),\n    })),\n  )\n}\n\nconst indexEpisodes = async (\n  providerId: string,\n  client: Client,\n  seasonFolderPath: string,\n): Promise<EpisodeIndexResponse[]> => {\n  const episodesResponse = await fetchItems(client, seasonFolderPath)\n\n  const episodes = await Promise.all(\n    episodesResponse.map(async (episodeResponse) => {\n      const number = Number.parseInt(episodeResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        files: await indexFiles(\n          providerId,\n          client,\n          `${seasonFolderPath}/${episodeResponse.name}`,\n        ),\n      }\n    }),\n  )\n\n  return episodes.filter(notUndefined)\n}\n\nconst indexSeasons = async (\n  providerId: string,\n  client: Client,\n  showFolderPath: string,\n): Promise<SeasonIndexResponse[]> => {\n  const seasonsResponse = await fetchItems(client, showFolderPath)\n\n  const seasons = await Promise.all(\n    seasonsResponse.map(async (seasonResponse) => {\n      const number = Number.parseInt(seasonResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        episodes: await indexEpisodes(\n          providerId,\n          client,\n          `${showFolderPath}/${seasonResponse.name}`,\n        ),\n      }\n    }),\n  )\n\n  return seasons.filter(notUndefined)\n}\n\nconst indexShows = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<ShowIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const showsResponse = await fetchItems(client, path)\n\n  return Promise.all(\n    showsResponse.map(async (showResponse) => ({\n      name: showResponse.name,\n      seasons: await indexSeasons(\n        providerId,\n        client,\n        `${path}/${showResponse.name}`,\n      ),\n    })),\n  )\n}\n\nexport const index = async (provider: FTP): Promise<IndexResponse> => {\n  const client = await getClient(\n    provider.host,\n    provider.port,\n    provider.username,\n    provider.password,\n    provider.secure,\n  )\n\n  return {\n    movies: await indexMovies(provider.id, client, provider.moviesPath),\n    shows: await indexShows(provider.id, client, provider.showsPath),\n  }\n}\n","import { DriveItemChildrenResponse, DriveItemResponse } from './types'\nimport { Client } from '@microsoft/microsoft-graph-client'\n\nexport const getClient = (accessToken: string) =>\n  Client.init({\n    authProvider: (done) => done(null, accessToken),\n  })\n\nexport const fetchPathChildren = (\n  client: Client,\n  path: string,\n): Promise<DriveItemChildrenResponse> =>\n  client.api(`/me/drive/root:${path}:/children`).get()\n\nexport const fetchItem = (\n  client: Client,\n  itemId: string,\n): Promise<DriveItemResponse> => client.api(`/me/drive/items/${itemId}`).get()\n\nexport const fetchItemChildren = (\n  client: Client,\n  itemId: string,\n): Promise<DriveItemChildrenResponse> =>\n  client.api(`/me/drive/items/${itemId}/children`).get()\n","import { Caption, CaptionType } from '../../../types/files/Caption'\nimport { DriveItemResponse, FileResponse, VideoResponse } from './types'\nimport { File, FileKind } from '../../../types/files/File'\nimport { Video, VideoType } from '../../../types/files/Video'\nimport {\n  buildFileId,\n  parseCaptionType,\n  parseFileName,\n  parseVideoType,\n} from '../util'\nimport { ProviderKind } from '../../../types/providers/Provider'\n\nconst buildCaption = (\n  providerId: string,\n  type: CaptionType,\n  name: string,\n  {\n    id,\n    name: fileName,\n    size,\n    webUrl,\n    '@microsoft.graph.downloadUrl': downloadUrl,\n  }: DriveItemResponse,\n  { mimeType }: FileResponse,\n): Caption => ({\n  kind: FileKind.Caption,\n  type,\n  id: buildFileId(ProviderKind.OneDrive, id),\n  name,\n  provider: {\n    kind: ProviderKind.OneDrive,\n    providerId,\n    id,\n    fileName,\n    size,\n    downloadUrl,\n    webUrl,\n    mimeType,\n  },\n})\n\nconst buildVideo = (\n  providerId: string,\n  type: VideoType,\n  name: string,\n  {\n    id,\n    name: fileName,\n    size,\n    webUrl,\n    '@microsoft.graph.downloadUrl': downloadUrl,\n  }: DriveItemResponse,\n  { mimeType }: FileResponse,\n  {\n    bitrate,\n    duration,\n    height,\n    width,\n    audioChannels,\n    audioFormat,\n    fourCC,\n    frameRate,\n  }: VideoResponse,\n): Video => ({\n  kind: FileKind.Video,\n  type,\n  id: buildFileId(ProviderKind.OneDrive, id),\n  name,\n  provider: {\n    kind: ProviderKind.OneDrive,\n    providerId,\n    id,\n    fileName,\n    size,\n    downloadUrl,\n    webUrl,\n    mimeType,\n    bitrate,\n    duration,\n    height,\n    width,\n    audioChannels,\n    audioFormat,\n    fourCC,\n    frameRate,\n  },\n})\n\nexport const buildFile =\n  (providerId: string) =>\n  (response: DriveItemResponse): File | undefined => {\n    if (response.file === undefined) return\n\n    const { name, extension } = parseFileName(response.name)\n    if (extension === undefined) return\n\n    const captionType = parseCaptionType(extension)\n    const videoType = parseVideoType(extension)\n\n    if (captionType !== undefined)\n      return buildCaption(\n        providerId,\n        captionType,\n        name,\n        response,\n        response.file,\n      )\n    else if (videoType !== undefined && response.video !== undefined)\n      return buildVideo(\n        providerId,\n        videoType,\n        name,\n        response,\n        response.file,\n        response.video,\n      )\n  }\n","import {\n  EpisodeIndexResponse,\n  IndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n  ShowIndexResponse,\n} from '../types'\nimport {\n  fetchItem,\n  fetchItemChildren,\n  fetchPathChildren,\n  getClient,\n} from './api'\nimport { CannotFindFileError } from '../../../errors/CannotFindFileError'\nimport { Client } from '@microsoft/microsoft-graph-client'\nimport { File } from '../../../types/files/File'\nimport { OneDrive } from '../../../types/providers/OneDrive'\nimport { ProviderKind } from '../../../types/providers/Provider'\nimport { buildFile } from './util'\nimport { notUndefined } from '../../../util'\n\nexport const updateFile = async (\n  provider: OneDrive,\n  file: File,\n): Promise<File> => {\n  const client = getClient(provider.accessToken.token)\n  if (file.provider.kind !== ProviderKind.OneDrive)\n    throw new Error(\n      'Internal error: attempted to update file with the wrong provider.',\n    )\n  const response = await fetchItem(client, file.provider.id)\n  const newFile = buildFile(provider.id)(response)\n\n  if (newFile !== undefined) return newFile\n  else throw new CannotFindFileError(file)\n}\n\nconst indexFiles = async (\n  providerId: string,\n  client: Client,\n  folderId: string,\n): Promise<File[]> => {\n  const { value: filesResponse } = await fetchItemChildren(client, folderId)\n\n  return filesResponse.map(buildFile(providerId)).filter(notUndefined)\n}\n\nconst indexMovies = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<MovieIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const { value: moviesResponse } = await fetchPathChildren(client, path)\n\n  return Promise.all(\n    moviesResponse.map(async (movieResponse) => ({\n      name: movieResponse.name,\n      files: await indexFiles(providerId, client, movieResponse.id),\n    })),\n  )\n}\n\nconst indexEpisodes = async (\n  providerId: string,\n  client: Client,\n  seasonFolderId: string,\n): Promise<EpisodeIndexResponse[]> => {\n  const { value: episodesResponse } = await fetchItemChildren(\n    client,\n    seasonFolderId,\n  )\n\n  const episodes = await Promise.all(\n    episodesResponse.map(async (episodeResponse) => {\n      const number = Number.parseInt(episodeResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        files: await indexFiles(providerId, client, episodeResponse.id),\n      }\n    }),\n  )\n\n  return episodes.filter(notUndefined)\n}\n\nconst indexSeasons = async (\n  providerId: string,\n  client: Client,\n  showFolderId: string,\n): Promise<SeasonIndexResponse[]> => {\n  const { value: seasonsResponse } = await fetchItemChildren(\n    client,\n    showFolderId,\n  )\n\n  const seasons = await Promise.all(\n    seasonsResponse.map(async (seasonResponse) => {\n      const number = Number.parseInt(seasonResponse.name)\n      if (isNaN(number)) return\n\n      return {\n        number,\n        episodes: await indexEpisodes(providerId, client, seasonResponse.id),\n      }\n    }),\n  )\n\n  return seasons.filter(notUndefined)\n}\n\nconst indexShows = async (\n  providerId: string,\n  client: Client,\n  path: string | undefined,\n): Promise<ShowIndexResponse[]> => {\n  if (path === undefined) return []\n\n  const { value: showsResponse } = await fetchPathChildren(client, path)\n\n  return Promise.all(\n    showsResponse.map(async (showResponse) => ({\n      name: showResponse.name,\n      seasons: await indexSeasons(providerId, client, showResponse.id),\n    })),\n  )\n}\n\nexport const index = async (provider: OneDrive): Promise<IndexResponse> => {\n  const client = getClient(provider.accessToken.token)\n\n  return {\n    movies: await indexMovies(provider.id, client, provider.moviesPath),\n    shows: await indexShows(provider.id, client, provider.showsPath),\n  }\n}\n","import {\n  EpisodeIndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n} from './types'\nimport { File, FileKind } from '../../types/files/File'\nimport { Provider, ProviderKind } from '../../types/providers/Provider'\nimport { Caption } from '../../types/files/Caption'\nimport { EpisodeLike } from '../../types/items/Episode'\nimport { ItemKind } from '../../types/items/Item'\nimport { MovieLike } from '../../types/items/Movie'\nimport { SeasonLike } from '../../types/items/Season'\nimport { ShowLike } from '../../types/items/Show'\nimport { Video } from '../../types/files/Video'\nimport { updateFile as ftpUpdateFile } from './FTP'\nimport { updateFile as oneDriveUpdateFile } from './OneDrive'\n\nconst isCaption = (file: File): file is Caption =>\n  file.kind === FileKind.Caption\n\nconst isVideo = (file: File): file is Video => file.kind === FileKind.Video\n\nexport const buildEpisodeLike =\n  (showTmdbId: number, seasonNumber: number) =>\n  (item: EpisodeIndexResponse): EpisodeLike => ({\n    kind: ItemKind.Episode,\n    number: item.number,\n    seasonNumber,\n    showTmdbId,\n    sources: item.files.filter(isVideo),\n    captions: item.files.filter(isCaption),\n    usage: {\n      lastWatched: undefined,\n      progress: undefined,\n    },\n  })\n\nexport const buildMovieLike =\n  (tmdbId: number) =>\n  (item: MovieIndexResponse): MovieLike => ({\n    kind: ItemKind.Movie,\n    tmdbId,\n    sources: item.files.filter(isVideo),\n    captions: item.files.filter(isCaption),\n    usage: {\n      lastWatched: undefined,\n      progress: undefined,\n    },\n  })\n\nexport const buildSeasonLike =\n  (showTmdbId: number) =>\n  (item: SeasonIndexResponse): SeasonLike => ({\n    kind: ItemKind.Season,\n    number: item.number,\n    showTmdbId,\n    usage: {\n      lastWatched: undefined,\n      progress: undefined,\n    },\n  })\n\nexport const buildShowLike = (tmdbId: number) => (): ShowLike => ({\n  kind: ItemKind.Show,\n  tmdbId,\n  usage: {\n    lastWatched: undefined,\n    progress: undefined,\n  },\n})\n\nexport const updateFile = (provider: Provider, file: File): Promise<File> => {\n  switch (provider.kind) {\n    case ProviderKind.FTP:\n      return ftpUpdateFile(provider, file)\n    case ProviderKind.OneDrive:\n      return oneDriveUpdateFile(provider, file)\n  }\n}\n","import { Episode, EpisodeLike } from '../types/items/Episode'\nimport {\n  EpisodeIndexResponse,\n  IndexResponse,\n  MovieIndexResponse,\n  SeasonIndexResponse,\n  ShowIndexResponse,\n} from './drives/types'\nimport { Movie, MovieLike } from '../types/items/Movie'\nimport { Provider, ProviderKind } from '../types/providers/Provider'\nimport { Season, SeasonLike } from '../types/items/Season'\nimport { Show, ShowLike } from '../types/items/Show'\nimport {\n  buildEpisodeLike,\n  buildMovieLike,\n  buildSeasonLike,\n  buildShowLike,\n} from './drives'\nimport { findMovie, findShow } from './databases/TMDb/api'\nimport { index as ftpIndex } from '../services/drives/FTP'\nimport { index as oneDriveIndex } from '../services/drives/OneDrive'\n\nconst handleProvider = (provider: Provider): Promise<IndexResponse> => {\n  switch (provider.kind) {\n    case ProviderKind.FTP:\n      return ftpIndex(provider)\n    case ProviderKind.OneDrive:\n      return oneDriveIndex(provider)\n  }\n}\n\nconst indexMovies = (\n  moviesResponse: MovieIndexResponse[],\n  fetchMovieMetadata: (movie: MovieLike) => Promise<Movie>,\n) =>\n  Promise.all(\n    moviesResponse.map(async (movieResponse) => {\n      const tmdbId = await findMovie(movieResponse.name)\n      if (tmdbId === undefined) return\n\n      const movieAlike = buildMovieLike(tmdbId)(movieResponse)\n      await fetchMovieMetadata(movieAlike)\n    }),\n  )\n\nconst indexShows = (\n  showsResponse: ShowIndexResponse[],\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n  fetchShowMetadata: (show: ShowLike) => Promise<Show>,\n) =>\n  Promise.all(\n    showsResponse.map(async (showResponse) => {\n      const tmdbId = await findShow(showResponse.name)\n      if (tmdbId === undefined) return\n\n      const showAlike = buildShowLike(tmdbId)()\n      const show = await fetchShowMetadata(showAlike)\n      await indexSeasons(\n        showResponse.seasons,\n        show,\n        fetchEpisodeMetadata,\n        fetchSeasonMetadata,\n      )\n    }),\n  )\n\nconst indexSeasons = (\n  seasonsResponse: SeasonIndexResponse[],\n  show: Show,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n) =>\n  Promise.all(\n    seasonsResponse.map(async (seasonResponse) => {\n      const seasonAlike = buildSeasonLike(show.tmdbId)(seasonResponse)\n      const season = await fetchSeasonMetadata(show, seasonAlike)\n      await indexEpisodes(\n        seasonResponse.episodes,\n        show,\n        season,\n        fetchEpisodeMetadata,\n      )\n    }),\n  )\n\nconst indexEpisodes = (\n  episodesResponse: EpisodeIndexResponse[],\n  show: Show,\n  season: Season,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n) =>\n  Promise.all(\n    episodesResponse.map(async (episodeResponse) => {\n      const episodeAlike = buildEpisodeLike(\n        show.tmdbId,\n        season.number,\n      )(episodeResponse)\n      await fetchEpisodeMetadata(show.id, season.id, episodeAlike)\n    }),\n  )\n\nexport const index = async (\n  provider: Provider,\n  fetchEpisodeMetadata: (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ) => Promise<Episode>,\n  fetchMovieMetadata: (movie: MovieLike) => Promise<Movie>,\n  fetchSeasonMetadata: (show: Show, season: SeasonLike) => Promise<Season>,\n  fetchShowMetadata: (show: ShowLike) => Promise<Show>,\n) => {\n  const { movies: moviesResponse, shows: showsResponse } = await handleProvider(\n    provider,\n  )\n\n  await indexMovies(moviesResponse, fetchMovieMetadata)\n  await indexShows(\n    showsResponse,\n    fetchEpisodeMetadata,\n    fetchSeasonMetadata,\n    fetchShowMetadata,\n  )\n}\n","import { Episode, EpisodeLike } from '../types/items/Episode'\nimport { Movie, MovieLike } from '../types/items/Movie'\nimport { Season, SeasonLike } from '../types/items/Season'\nimport { Show, ShowLike } from '../types/items/Show'\nimport { episodeSelector, episodesSelector } from './episodes/selectors'\nimport {\n  fetchEpisodeMetadata as fetchEpisodeMetadataCall,\n  fetchMovieMetadata as fetchMovieMetadataCall,\n  fetchSeasonMetadata as fetchSeasonMetadataCall,\n  fetchShowMetadata as fetchShowMetadataCall,\n} from '../services/databases/TMDb'\nimport { movieSelector, moviesSelector } from './movies/selectors'\nimport { seasonSelector, seasonsSelector } from './seasons/selectors'\nimport { showSelector, showsSelector } from './shows/selectors'\nimport { AppThunk } from '.'\nimport { Caption } from '../types/files/Caption'\nimport { File } from '../types/files/File'\nimport { ItemKind } from '../types/items/Item'\nimport { Provider } from '../types/providers/Provider'\nimport { Video } from '../types/files/Video'\nimport { auth as authCall } from './auth/thunks'\nimport { removeFilesByProvider as episodeRemoveFilesByProvider } from './episodes/thunks'\nimport { index as indexCall } from '../services/indexing'\nimport { removeFilesByProvider as movieRemoveFilesByProvider } from './movies/thunks'\nimport { providerSelector } from './auth/selectors'\nimport { removeProvider as removeProviderAction } from './auth/actions'\nimport { updateEpisode } from './episodes/actions'\nimport { updateFile as updateFileCall } from '../services/drives'\nimport { updateMovie } from './movies/actions'\nimport { updateSeason } from './seasons/actions'\nimport { updateShow } from './shows/actions'\n\nexport const index =\n  (providers: Provider[]): AppThunk<Promise<void>> =>\n  async (dispatch) => {\n    await Promise.all(\n      providers.map(async (provider) => {\n        const updatedProvider = await dispatch(authCall(provider))\n        if (updatedProvider === undefined)\n          throw new Error(\n            'cannot sign in using the redirect flow while updating files',\n          )\n\n        await indexCall(\n          updatedProvider,\n          (showId: string, seasonId: string, episode: EpisodeLike) =>\n            dispatch(fetchEpisodeMetadata(showId, seasonId, episode)),\n          (movie: MovieLike) => dispatch(fetchMovieMetadata(movie)),\n          (show: Show, season: SeasonLike) =>\n            dispatch(fetchSeasonMetadata(show, season)),\n          (show: ShowLike) => dispatch(fetchShowMetadata(show)),\n        )\n      }),\n    )\n  }\n\nconst updateFile =\n  (file: File): AppThunk<Promise<File>> =>\n  async (dispatch, getState) => {\n    const { auth } = getState()\n    const provider = providerSelector(file.provider.providerId)(auth)\n    if (provider === undefined)\n      throw new Error('could not find provider for file')\n\n    const updatedProvider = await dispatch(authCall(provider))\n    if (updatedProvider === undefined)\n      throw new Error(\n        'cannot sign in using the redirect flow while updating files',\n      )\n\n    const updatedFile = await updateFileCall(updatedProvider, file)\n\n    return updatedFile\n  }\n\nconst handleUpdateWatchableItem = (item: Episode | Movie) => {\n  switch (item.kind) {\n    case ItemKind.Episode:\n      return updateEpisode(item)\n    case ItemKind.Movie:\n      return updateMovie(item)\n  }\n}\n\nexport const updateFiles =\n  (item: Episode | Movie): AppThunk<Promise<Episode | Movie>> =>\n  async (dispatch) => {\n    const sources = await Promise.all(\n      item.sources.map(\n        (source) => dispatch(updateFile(source)) as Promise<Video>,\n      ),\n    )\n    const captions = await Promise.all(\n      item.captions.map(\n        (caption) => dispatch(updateFile(caption)) as Promise<Caption>,\n      ),\n    )\n    const updatedItem = {\n      ...item,\n      sources,\n      captions,\n    }\n\n    handleUpdateWatchableItem(updatedItem)\n    return updatedItem\n  }\n\nconst fetchEpisodeMetadata =\n  (\n    showId: string,\n    seasonId: string,\n    episode: EpisodeLike,\n  ): AppThunk<Promise<Episode>> =>\n  async (dispatch, getState) => {\n    const { episodes } = getState()\n\n    const newEpisode = await fetchEpisodeMetadataCall(showId, seasonId, episode)\n    const oldEpisode = episodeSelector(newEpisode.id)(episodes)\n    if (oldEpisode !== undefined) newEpisode.usage = oldEpisode.usage\n\n    dispatch(updateEpisode(newEpisode))\n    return newEpisode\n  }\n\nconst fetchMovieMetadata =\n  (movie: MovieLike): AppThunk<Promise<Movie>> =>\n  async (dispatch, getState) => {\n    const { movies } = getState()\n\n    const newMovie = await fetchMovieMetadataCall(movie)\n    const oldMovie = movieSelector(newMovie.id)(movies)\n    if (oldMovie !== undefined) newMovie.usage = oldMovie.usage\n\n    dispatch(updateMovie(newMovie))\n    return newMovie\n  }\n\nconst fetchSeasonMetadata =\n  (show: Show, season: SeasonLike): AppThunk<Promise<Season>> =>\n  async (dispatch, getState) => {\n    const { seasons } = getState()\n\n    const newSeason = await fetchSeasonMetadataCall(show, season)\n    const oldSeason = seasonSelector(newSeason.id)(seasons)\n    if (oldSeason !== undefined) newSeason.usage = oldSeason.usage\n\n    dispatch(updateSeason(newSeason))\n    return newSeason\n  }\n\nconst fetchShowMetadata =\n  (show: ShowLike): AppThunk<Promise<Show>> =>\n  async (dispatch, getState) => {\n    const { shows } = getState()\n\n    const newShow = await fetchShowMetadataCall(show)\n    const oldShow = showSelector(newShow.id)(shows)\n    if (oldShow !== undefined) newShow.usage = oldShow.usage\n\n    dispatch(updateShow(newShow))\n    return newShow\n  }\n\nconst fetchEpisodesMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { episodes } = getState()\n\n    await Promise.all(\n      episodesSelector(episodes).map(async (episode) =>\n        dispatch(\n          fetchEpisodeMetadata(episode.showId, episode.seasonId, episode),\n        ),\n      ),\n    )\n  }\n\nconst fetchMoviesMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { movies } = getState()\n\n    await Promise.all(\n      moviesSelector(movies).map(async (movie) =>\n        dispatch(fetchMovieMetadata(movie)),\n      ),\n    )\n  }\n\nconst fetchSeasonsMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { seasons, shows } = getState()\n\n    await Promise.all(\n      seasonsSelector(seasons).map(async (season) => {\n        const show = showSelector(season.showId)(shows)\n        if (show === undefined) throw new Error('cannot find show for season')\n\n        return dispatch(fetchSeasonMetadata(show, season))\n      }),\n    )\n  }\n\nconst fetchShowsMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch, getState) => {\n    const { shows } = getState()\n\n    await Promise.all(\n      showsSelector(shows).map(async (show) =>\n        dispatch(fetchShowMetadata(show)),\n      ),\n    )\n  }\n\nexport const fetchAllMetadata =\n  (): AppThunk<Promise<void>> => async (dispatch) => {\n    await dispatch(fetchMoviesMetadata())\n    await dispatch(fetchShowsMetadata())\n    await dispatch(fetchSeasonsMetadata())\n    await dispatch(fetchEpisodesMetadata())\n  }\n\nexport const removeProvider =\n  (id: string): AppThunk<void> =>\n  (dispatch, getState) => {\n    dispatch(removeProviderAction(id))\n\n    const { episodes, movies } = getState()\n    episodesSelector(episodes).forEach((episode) =>\n      dispatch(episodeRemoveFilesByProvider(episode, id)),\n    )\n    moviesSelector(movies).forEach((movie) =>\n      dispatch(movieRemoveFilesByProvider(movie, id)),\n    )\n  }\n","import { EpisodesActionTypes, REMOVE_EPISODE, UPDATE_EPISODE } from './types'\nimport { Episode } from '../../types/items/Episode'\n\nexport const updateEpisode = (episode: Episode): EpisodesActionTypes => ({\n  type: UPDATE_EPISODE,\n  payload: { episode },\n})\n\nexport const removeEpisode = (id: string): EpisodesActionTypes => ({\n  type: REMOVE_EPISODE,\n  payload: { id },\n})\n","import { REMOVE_SEASON, SeasonsActionTypes, UPDATE_SEASON } from './types'\nimport { Season } from '../../types/items/Season'\n\nexport const updateSeason = (season: Season): SeasonsActionTypes => ({\n  type: UPDATE_SEASON,\n  payload: { season },\n})\n\nexport const removeSeason = (id: string): SeasonsActionTypes => ({\n  type: REMOVE_SEASON,\n  payload: { id },\n})\n","import { REMOVE_SHOW, ShowsActionTypes, UPDATE_SHOW } from './types'\nimport { Show } from '../../types/items/Show'\n\nexport const updateShow = (show: Show): ShowsActionTypes => ({\n  type: UPDATE_SHOW,\n  payload: { show },\n})\n\nexport const removeShow = (id: string): ShowsActionTypes => ({\n  type: REMOVE_SHOW,\n  payload: { id },\n})\n","import { AppThunk } from '../index'\nimport { Movie } from '../../types/items/Movie'\nimport { Usage } from '../../types/items/Item'\nimport { updateMovie } from './actions'\n\nexport const updateMovieProgress =\n  (movie: Movie, progress: number): AppThunk<void> =>\n  (dispatch) => {\n    const usage: Usage = {\n      lastWatched: new Date().toISOString(),\n      progress,\n    }\n    dispatch(updateMovie({ ...movie, usage }))\n  }\n\nexport const removeFilesByProvider =\n  (movie: Movie, providerId: string): AppThunk<void> =>\n  (dispatch) => {\n    dispatch(\n      updateMovie({\n        ...movie,\n        sources: movie.sources.filter(\n          (source) => source.provider.providerId !== providerId,\n        ),\n        captions: movie.captions.filter(\n          (caption) => caption.provider.providerId !== providerId,\n        ),\n      }),\n    )\n  }\n","import { MoviesActionTypes, REMOVE_MOVIE, UPDATE_MOVIE } from './types'\nimport { Movie } from '../../types/items/Movie'\n\nexport const updateMovie = (movie: Movie): MoviesActionTypes => ({\n  type: UPDATE_MOVIE,\n  payload: { movie },\n})\n\nexport const removeMovie = (id: string): MoviesActionTypes => ({\n  type: REMOVE_MOVIE,\n  payload: { id },\n})\n","import { AppThunk } from '../index'\nimport { Season } from '../../types/items/Season'\nimport { Usage } from '../../types/items/Item'\nimport { showSelector } from '../shows/selectors'\nimport { updateSeason } from './actions'\nimport { updateShowProgress } from '../shows/thunks'\n\nexport const updateSeasonProgress =\n  (season: Season, progress: number): AppThunk<void> =>\n  (dispatch, getState) => {\n    const usage: Usage = {\n      lastWatched: new Date().toISOString(),\n      progress,\n    }\n    dispatch(updateSeason({ ...season, usage }))\n\n    const { shows } = getState()\n    const show = showSelector(season.showId)(shows)\n    if (show === undefined) throw new Error('parent show of season undefined')\n\n    dispatch(updateShowProgress(show, season.number))\n  }\n","import { AppThunk } from '../index'\nimport { Show } from '../../types/items/Show'\nimport { Usage } from '../../types/items/Item'\nimport { updateShow } from './actions'\n\nexport const updateShowProgress =\n  (show: Show, progress: number): AppThunk<void> =>\n  (dispatch) => {\n    const usage: Usage = {\n      lastWatched: new Date().toISOString(),\n      progress,\n    }\n    dispatch(updateShow({ ...show, usage }))\n  }\n","import { AppThunk } from '../index'\nimport { Episode } from '../../types/items/Episode'\nimport { Usage } from '../../types/items/Item'\nimport { seasonSelector } from '../seasons/selectors'\nimport { updateEpisode } from './actions'\nimport { updateSeasonProgress } from '../seasons/thunks'\n\nexport const updateEpisodeProgress =\n  (episode: Episode, progress: number): AppThunk<void> =>\n  (dispatch, getState) => {\n    const usage: Usage = {\n      lastWatched: new Date().toISOString(),\n      progress,\n    }\n    dispatch(updateEpisode({ ...episode, usage }))\n\n    const { seasons } = getState()\n    const season = seasonSelector(episode.seasonId)(seasons)\n    if (season === undefined)\n      throw new Error('parent season of episode undefined')\n\n    dispatch(updateSeasonProgress(season, episode.number))\n  }\n\nexport const removeFilesByProvider =\n  (episode: Episode, providerId: string): AppThunk<void> =>\n  (dispatch) => {\n    dispatch(\n      updateEpisode({\n        ...episode,\n        sources: episode.sources.filter(\n          (source) => source.provider.providerId !== providerId,\n        ),\n        captions: episode.captions.filter(\n          (caption) => caption.provider.providerId !== providerId,\n        ),\n      }),\n    )\n  }\n"],"sourceRoot":""}